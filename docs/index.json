[
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/building/",
	"title": "Building",
	"tags": [],
	"description": "",
	"content": "MISA++ uses the CMake build system (version 3.12.2) and is designed around the GCC compiler. We tested compilation under GCC version 7.3.\nInfo: Newer versions than CMake 3.12.2 might have issues with compiling OME files.\nIf you want to use another compiler, check if it supports C++ 2017 or higher and OpenMP 4.5 or higher. We only used OpenMP 3.x features, so using an older OpenMP version might work.\nYou will also need following additional libraries:\n   Library Version Notes     Boost 1.67    SQLite 3    OME files 0.5.0 See https://www.openmicroscopy.org/ for download and build instructions   OpenCV 3.x or 4.x    JSON for Modern C++ 3.5.0 See https://github.com/nlohmann/json    The MISA++ libraries and applications we provide depend on each other:\nmermaid.initialize({startOnLoad:true}); graph TB; A[MISA++ Core] -- B[MISA++ Imaging] A -- C[MISA++ Result Analyzer] B -- D[MISA++ OME] D -- E[\"MISA++ Tissue Segmentation\"] E -- F[\"MISA++ Kidney Glomeruli Segmentation\"] B -- G[\"MISA++ OME Visualizer\"]  Please make sure to build the dependencies the correct order.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/imagej/result-analyzer/output-data/",
	"title": "Evaluating output data",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/imagej/",
	"title": "ImageJ plugin",
	"tags": [],
	"description": "",
	"content": "The MISA++ (Modular image stack analysis for C++) framework allows the creation of C++ applications to process data. It features functions that simplify following common requirements of such applications:\n Automated parallelization of tasks Memory-efficient caching of data on hard-drive Providing additional algorithm parameters Modularization of common tasks Assigning quantitative results to data Integration into other tools and pipelines  MISA++ is used to develop modules that either provide additional data types and other utility functions (utility modules) or modules that are compiled into an application that solves a specific task (worker modules).\nWe also provide additional modules that integrate the open source imaging libraries OpenCV and OME Files into our framework.\nAll features Core library Creation of parallelizeable workloads  Easy creation of parallelizable and atomic tasks Easy structuring of tasks into groups Dependency management between workloads No need for manual thread creation due to automated parallelization  Standardized input parameters  Highly structured and well standardized way to create algorithm parameters Different parameter namespaces   Algorithm-specific parameters     Sample-specific parameters     Global parameters    Memory-efficient handling of large data sets  Data-access via thread-safe caches Easy importing of input data Easy creation of output data Methods to easily create new cache types  Assigning quantification results  Quantification results can be easily attached to input or output data Well-defined, fully-automated and portable way to assign quantification results to data for external tools Predefined data cache that acts as shared storage for quantified data  CMake build system integration  Automated generation of installable shared libraries Automated generation of installable executables for worker modules  Support for quantified data  Matrix data type including mathematical operations Values with unit   Unit conversions     Higher order units    Imaging capabilities OpenCV integration  Single-image cache Image stack cache   Allows access to each single-image cache     Easy parallelization    OME Files integration  OME TIFF cache that allows access to individual OME TIFF planes   Can read OME TIFF format including metadata     Can write OME TIFF format including metadata   Automated conversion from/to OpenCV images Read and write access to OME metadata such as microscopy parameters or physical size Support for OME quantity types   Including higher-order quantity types such as area and volume     Voxel/3D quantity types    "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/imagej/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": "Building from source Building MISA++ for ImageJ requires the Maven build system and that a JDK installation is present on the current system.\n Download the source code Navigate into the source directory Run mvn package  The misa_imagej plugin can be found in the target directory. Copy it into the ImageJ plugin directory.\nMISA++ for ImageJ requires additional libraries that do not come pre-installed with ImageJ or Fiji.\nCopy following libraries from target/dependencies into the ImageJ jars directory:\n autolink flexmark graphics2d jfreesvg openhtmltopdf pdfbox poi sqlite bcprov-jdk15on bcpkix-jdk15on icepdf commons-exec  Windows superbuild MISA++ for ImageJ is part of the Windows superbuild. See Building for more information.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/development/prerequisites/",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": "MISA++ uses the CMake build system. Please make sure that CMake version 3.13 or higher is installed.\nThe compiler must support C++ version 2017 or higher.\nFor Windows, we recommend the Cygwin environment.\nPlease note that the Visual Studio compiler is not supported due to missing OpenMP 3.x capabilities.\n Make sure that MISA++ Core and any other dependency modules are installed. See Building for more information about building MISA++ and already existing modules.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/imagej/result-analyzer/quantification-results/",
	"title": "Browsing quantification results",
	"tags": [],
	"description": "",
	"content": "\u0026lt;col /\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;b\u0026gt;Filter\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;b\u0026gt;Description\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_7e9251409421e5be.png\u0026quot; name=\u0026quot;image95.png\u0026quot; class=\u0026quot;inline-image\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;  Filter by SQLAllows insertion of a custom SQL filter query.Filter by dataFilters quantification results that are attached to specific data.Filter by object typeRestricts the object types (e.g. only list glomeruli).Filter by sampleOnly shows quantification results of specified samples.Filter only direct attachmentsMISA++ quantification results are hierarchical. With this filter, objects deeper down in the hierarchy are hidden.\u0026lt;col /\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;b\u0026gt;Action\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;b\u0026gt;Description\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_7e9251409421e5be.png\u0026quot; name=\u0026quot;image2.png\u0026quot; class=\u0026quot;inline-image\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;  Automatically updateIf enabled (default), the tree is automatically updated when a filter is changed. \u0026lt;/p\u0026gt; \u0026lt;p \u0026gt;Disable this feature if you change lots of filter settings at once and don’t want to wait for the database update.\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_741a8f89f0bfae4f.png\u0026quot; name=\u0026quot;image5.png\u0026quot; class=\u0026quot;inline-image\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;  UpdateUpdates the tree manually.Copy as SQL queryCopies the current selection as SQL query. This includes the SQL query from filtering.Display by dataIf enabled (default), the tree is organized by sample → data → sub-data → type → property.Display by object typeIf enabled, the tree is organized by MISA++ application → type → data → sample → property.\u0026lt;col /\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;b\u0026gt;Action\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;b\u0026gt;Description\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_7e9251409421e5be.png\u0026quot; name=\u0026quot;Image6\u0026quot; class=\u0026quot;inline-image\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;  Automatically updateIf enabled (default), the table is automatically updated when a filter is changed or the selection the tree changes.UpdateUpdates the table manually.ExportSaves the table as *.csv or *.xlsxAnalyzeOpens a tool to further analyze the table (see Summarizing quantification results).Current objectTables can only be created for one object type. Use this selection to change the object type.Edit columnsBy default, the table does not contain all properties of the current object. The column editor allows you to include more columns or exclude unnecessary information."
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/",
	"title": "C++ Framework",
	"tags": [],
	"description": "",
	"content": "The MISA++ (Modular image stack analysis for C++) framework allows the creation of C++ applications to process data. It features functions that simplify following common requirements of such applications:\n Automated parallelization of tasks Memory-efficient caching of data on hard-drive Providing additional algorithm parameters Modularization of common tasks Assigning quantitative results to data Integration into other tools and pipelines  MISA++ is used to develop modules that either provide additional data types and other utility functions (utility modules) or modules that are compiled into an application that solves a specific task (worker modules).\nWe also provide additional modules that integrate the open source imaging libraries OpenCV and OME Files into our framework.\nAll features Core library Creation of parallelizeable workloads  Easy creation of parallelizable and atomic tasks Easy structuring of tasks into groups Dependency management between workloads No need for manual thread creation due to automated parallelization  Standardized input parameters  Highly structured and well standardized way to create algorithm parameters Different parameter namespaces   Algorithm-specific parameters     Sample-specific parameters     Global parameters    Memory-efficient handling of large data sets  Data-access via thread-safe caches Easy importing of input data Easy creation of output data Methods to easily create new cache types  Assigning quantification results  Quantification results can be easily attached to input or output data Well-defined, fully-automated and portable way to assign quantification results to data for external tools Predefined data cache that acts as shared storage for quantified data  CMake build system integration  Automated generation of installable shared libraries Automated generation of installable executables for worker modules  Support for quantified data  Matrix data type including mathematical operations Values with unit   Unit conversions     Higher order units    Imaging capabilities OpenCV integration  Single-image cache Image stack cache   Allows access to each single-image cache     Easy parallelization    OME Files integration  OME TIFF cache that allows access to individual OME TIFF planes   Can read OME TIFF format including metadata     Can write OME TIFF format including metadata   Automated conversion from/to OpenCV images Read and write access to OME metadata such as microscopy parameters or physical size Support for OME quantity types   Including higher-order quantity types such as area and volume     Voxel/3D quantity types    "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/running/",
	"title": "Running",
	"tags": [],
	"description": "",
	"content": "To run a module, you can either run it using a graphical user interface such as the MISA++ ImageJ plugin or run it directly via the command line.\nCommand line interface A worker module is an executable that has a command line interface (CLI). You can always run \u0026lt;module\u0026gt; --help to show all parameters.\nTo run a workload, run \u0026lt;module\u0026gt; --parameters \u0026lt;parameter file\u0026gt;. It will start doing the tasks and exits after they are done. The CLI also allows you to quickly change some runtime parameters without editing the parameter file. You can override the number of threads using --threads \u0026lt;number of threads\u0026gt; and enable the complete runtime log with --full-runtime-log.\nYou can also query the version and full module info in JSON format using --version and --module-info respectively.\nEach runnable module is able to create a description of its parameter file, input and output directory structure and data types. This parameter schema is generated using --write-parameter-schema \u0026lt;file\u0026gt;. No parameter file is necessary to generate a parameter schema.\nAll necessary information will also be written into the output directory after the module finishes its work.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/development/development-environment/",
	"title": "Setting up a project",
	"tags": [],
	"description": "",
	"content": "Automated project creation We provide scripts for Linux and Windows that automate creating a valid MISA++ project. The resulting project folders can be directly compiled.\nYou can find the scripts on our GitHub page.\nLinux  Copy the misaxx-create-project.sh script into a folder Open a terminal and make the script executable via chmod +x misaxx-create-project.sh Run misaxx-create-project.sh and follow the instructions  Windows  Copy the misaxx-create-project.ps1 script into a folder Right click the script and click \u0026ldquo;Run in Powershell\u0026rdquo; Follow the instructions  Manual project creation Following guide shows how to create a project manually.\nCreating the folder structure Each module is designed to be compiled into a shared library (.dll/.so), which requires a strict separation between the API and implementation. Create following folder structure:\n./CMakeLists.txt ./include/\u0026lt;module-name\u0026gt;/ ./src/\u0026lt;module-name\u0026gt;/ \u0026lt;module-name\u0026gt; is the name of the CMake target, for example misaxx-ome. The include directory contains the public API of the module and will be installed into the global include directory. The src directory contains implementation-only files and will not be installed.\nCreating the CMakeLists.txt The following CMakeLists.txt file makes use of helper functions that are automatically imported on making use of the MISA++ Core package. You are of course free to setup your project without those functions.\n Fill the CMakeLists.txt file with following information:\ncmake_minimum_required(VERSION 3.11) # Or higher if required project(\u0026lt;module-name\u0026gt; VERSION \u0026lt;module-version\u0026gt; DESCRIPTION \u0026#34;\u0026lt;Short description\u0026gt;\u0026#34;)find_package(misaxx-core REQUIRED)# Add additional packages if necessary add_library(\u0026lt;module-name\u0026gt; \u0026lt;Files ...\u0026gt;)# Add additional link targets if necessary target_link_libraries(\u0026lt;module-name\u0026gt; misaxx::misaxx-core)# MISA++ helper script (automatically included by Core Library) set(MISAXX_LIBRARY \u0026lt;module-name\u0026gt;)set(MISAXX_LIBRARY_NAMESPACE \u0026lt;module-namespace\u0026gt;::)set(MISAXX_API_NAME \u0026lt;module_name\u0026gt;)set(MISAXX_API_INCLUDE_PATH \u0026lt;module-name\u0026gt;)set(MISAXX_API_NAMESPACE \u0026lt;module_name\u0026gt;)misaxx_with_default_module_info()misaxx_with_default_api()# Only if it\u0026#39;s a worker module: misaxx_with_default_executable()Please note that \u0026lt;module-name\u0026gt; and \u0026lt;module_name\u0026gt; might be different. \u0026lt;module_name\u0026gt; must be a name that is valid in C++.\nFor worker modules: Create the module interface and module dispatcher If you want to create a module that performs processing of data, create the following files:\n./include/\u0026lt;module-name\u0026gt;/module_interface.h ./include/\u0026lt;module-name\u0026gt;/module.h ./src/\u0026lt;module-name\u0026gt;/module_interface.cpp ./src/\u0026lt;module-name\u0026gt;/module.cpp Please no not forget to add them to the CMakeLists.txt\nmodule_interface.h #include \u0026lt;misaxx/core/misa_module_interface.h\u0026gt; namespace \u0026lt;module_name\u0026gt; { struct module_interface : public misaxx::misa_module_interface { void setup() override; } } module.h #include \u0026lt;misaxx/core/misa_module.h\u0026gt; namespace \u0026lt;module_name\u0026gt; { struct module : public misaxx::misa_module\u0026lt;module_interface\u0026gt; { using misaxx::misa_module\u0026lt;module_interface\u0026gt;::misa_module; void create_blueprints(blueprint_list \u0026amp;t_blueprints, parameter_list \u0026amp;t_parameters) override; void build(const blueprint_builder \u0026amp;t_builder) override; } } Initial configuration Create a building directory and run cmake .. once. This will automatically generate additional code files such as the module info.\nmkdir build cd build cmake .. Add following files to your CMake target:\n./include/\u0026lt;module-name\u0026gt;/module_info.h ./src/\u0026lt;module-name\u0026gt;/module_info.cpp "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/imagej/step-by-step/",
	"title": "Tutorial: Step by step analysis",
	"tags": [],
	"description": "",
	"content": "Prerequisites  Make sure that MISA++ Kidney Glomeruli Segmentation and MISA++ Result Analyzer are installed Make sure that the MISA++ ImageJ plugin is installed Download the example data  Video tutorial The video tutorial covers the same steps as the written tutorial.\nWritten tutorial \u0026lt;col /\u0026gt; \u0026lt;tr valign=\u0026quot;top\u0026quot;\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_cb89aec853a553cd.png\u0026quot; name=\u0026quot;image138.png\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;   \u0026lt;/p\u0026gt; \u0026lt;p \u0026gt;Click \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_63631d3be680189.png\u0026quot; class=\u0026quot;inline-image\u0026quot; name=\u0026quot;image80.png\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;  Launchto open a tool that allows preparation of the data and changing parameters. \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr valign=\u0026quot;top\u0026quot;\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p\u0026gt; \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_d51c71947cefea0d.png\u0026quot; name=\u0026quot;image128.png\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;   \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr valign=\u0026quot;top\u0026quot;\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p\u0026gt; \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_ffb1140b27a42629.png\u0026quot; name=\u0026quot;image16.png\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;   \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Then delete the default sample “\u0026lt;img class=\u0026quot;inline-image\u0026quot; src=\u0026quot;/img/imagej/userguide_html_e507c96bf16d7da5.png\u0026quot; name=\u0026quot;image141.png\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;  New Sample”, as we already imported all necessary data. \u0026lt;/p\u0026gt; \u0026lt;p \u0026gt;Click \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_63631d3be680189.png\u0026quot; class=\u0026quot;inline-image\u0026quot; name=\u0026quot;image76.png\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;  Runand then Run nowto start the analysis. After the analysis finished, the plugin will ask you to further analyze the results. \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt;  \u0026lt;col /\u0026gt; \u0026lt;tr valign=\u0026quot;top\u0026quot;\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_7e1d387f696b79e7.png\u0026quot; name=\u0026quot;image33.png\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;   \u0026lt;/p\u0026gt; \u0026lt;p \u0026gt;This will open a tool to browse and filter quantification results and transform them into tables that can be plotted.\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr valign=\u0026quot;top\u0026quot;\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_7c7db2265df6ffa2.png\u0026quot; name=\u0026quot;image145.png\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;   \u0026lt;/p\u0026gt; \u0026lt;p \u0026gt;Click \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_96edca7cbbbe705d.png\u0026quot; class=\u0026quot;inline-image\u0026quot; name=\u0026quot;image118.png\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;  Clear selectionand select the columns Samplediameter/Valuediameter/Unit/unitValid \u0026lt;/p\u0026gt; \u0026lt;p \u0026gt;This will open a tool that allows you to modify the table and perform statistics.\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr valign=\u0026quot;top\u0026quot;\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_6c577a41ad99985a.png\u0026quot; name=\u0026quot;image140.png\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;   \u0026lt;/p\u0026gt; \u0026lt;p \u0026gt;\u0026lt;br/\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p \u0026gt;\u0026lt;br/\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr valign=\u0026quot;top\u0026quot;\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_45fc33e19f6e192d.png\u0026quot; name=\u0026quot;image136.png\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;   \u0026lt;/p\u0026gt; \u0026lt;p \u0026gt;Click \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_a590cddcece250fa.png\u0026quot; class=\u0026quot;inline-image\u0026quot; name=\u0026quot;image24.png\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;  Undoto restore the original table and then Create plot."
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/development/declaring-data/",
	"title": "Declaring data",
	"tags": [],
	"description": "",
	"content": "MISA++ organizes input and output data in caches. Caches provide functionality to access large datasets in a memory-efficient way. To be able to achieve this, they are linked to a location within the filesystem (a folder). The cache-implementation loads data into the memory on-demand and frees space if there is no demand left.\nCaches are exclusively created within the module interface that is also responsible for triggering the linking process between a folder and the cache implementation.\nDeclaring and linking caches To define that a cache is part of the interface, declare a variable of misa::misa_cached_data\u0026lt;T\u0026gt;. This instance is called an accessor, which is a shared pointer to the actual cache. Accessors are designed to include additional helper functions to make working with the specific cache type easier.\nLinking of a cache is done within the setup() method of the module interface. In most cases, it is most reasonable to use the suggest_import_location(...) or suggest_export_location(...) functions to link a cache.\nThe paths provided to suggest_import_location(...) and suggest_export_location(...) are relative to the virtual filesystem of the current module. The framework will automatically handle the organization of the files within the physical filesystem.\n Input data To declare input data, use the suggest_import_location(...) function. It loads a location from the filesystem if the cache was not already set from a parent module. Its first parameter, filesystem is the filesystem that is directly available from within the module interface. The second parameter describes the location within the input folder.\n The filesystem of a module interface is always relative. You do not have to account for your module being instantiated as a submodule.\n Output data suggest_export_location(...) creates a new location within the output folder that will contain the generated data. It has a third parameter that contains all necessary information for the cache to create an output. The type of this description differs from cache to cache.\nmermaid.initialize({startOnLoad:true}); graph TD; Description--|export|Cache Cache--|describe|Description Filesystem---|link|Cache  Examplestruct module_interface : public misa_module_interface { misaxx::ome::misa_ome_tiff m_input; misaxx::ome::misa_ome_tiff m_output; void setup(); } module_interface::setup() { m_input.suggest_import_location(filesystem, \u0026#34;input\u0026#34;); // Link to \u0026lt;input folder\u0026gt;/input  m_output.suggest_export_location(filesystem, \u0026#34;output\u0026#34;, m_input.describe()); // Link to \u0026lt;output folder\u0026gt;/output. The output cache will have the same properties as the input }  Accessing cached data Caches load data from hard disk on demand and are implemented in a way that minimizes read and write operations. Any cache accessor comes with 3 methods:\nreadonly_access \u0026lt;value_type\u0026gt; access_readonly(); write_access \u0026lt;value_type\u0026gt; access_write(); readwrite_access \u0026lt;value_type\u0026gt; access_readwrite(); Those methods create proxy objects that ensure the correct state of the cache.\nMake sure to not destroy the proxy objects prematurely. The cache might invalidate the data.\n Access via proxy-objects or accessor-specific helper methods is thread-safe and uses a shared mutex to allow multiple threads to read the data, but only one thread to write it.\nPlease be careful to not circumvent cache access, as it can lead to lost data or errors.\n Example void work() { auto access = m_input.access_readonly(); cv::countNonZero(access.get()); // Proxy object will be destroyed } "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/development/",
	"title": "Development",
	"tags": [],
	"description": "",
	"content": "To develop a MISA++ module, follow the steps as listed below:\n Installing prerequisites Creating the project Declaring input and output data Creating tasks, dispatchers and re-using other modules Attach quantification data during processing  If you want to extends the existing functionality of MISA++, take a look at our guide to create a new data type. It can also be helpful to take a look at our additional tips and tricks.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/download/",
	"title": "Download",
	"tags": [],
	"description": "",
	"content": "All platforms: ImageJ plugin If you only want the plugin or are using an operating system other than Windows, download following package:\nDownload plugin (Windows, Linux)  This download contains only the plugin and dependency libraries. Please do not forget to obtain compiled MISA++ packages for your operating system that are interfaced with the plugin.\n Linux We provide ready-to-install packages for Ubuntu 18.04 and Ubuntu 19.10 that contains following components:\n MISA++ core components (MISA++ Core, MISA++ Analyzer) Example implementations of third-party library integrations (OpenCV, OME TIFF) Example implementations of image analysis algorithms (Tissue segmentation, Kidney glomeruli segmenation, OME visualizer, and more) ImageJ plugin binaries, including dependency libraries   Download MISA++ for Ubuntu 18.04 Download MISA++ for Ubuntu 19.10 Download MISA++ for Ubuntu 20.04 You can install the *.deb packages using sudo apt install ./*.deb. Put the plugin files (located in the misa-imagej folder) into an existing Fiji installation to install the ImageJ plugin.\nWindows We provide a ready-to-use Fiji distribution that comes pre-installed with MISA++ for ImageJ, MISA++ Kidney Glomeruli Segmentation, MISA++ Tissue Segmentation, MISA++ OME Visualizer, MISA++ Microbenchmarks, MISA++ Deconvolution Simulation, MISA++ Cell Segmentation and MISA++ Result Analyzer.\nAlternatively, you can download only the MISA++ binaries.\n Download MISA+Fiji for Windows x64 Download MISA++ binaries for Windows x64 MISA++ is developed on Linux - We consider this Windows release as experimental. We are aware of a bug that causes freezes of multi-threaded MISA++ workloads if executed from within ImageJ. As workaround, export MISA++ runs as standalone package and run MISA++ via the command line interface.\n Please make sure that your anti virus protection does not block the MISA++ application. Try refreshing the list of modules if a module could not be loaded.\n Source code The software is Open Source and licensed under BSD-2-Clause. You can find the source codes of the MISA++ framework, modules and applications under following links:\n   Library Source code Class reference     MISA++ Core Download source code  Open    MISA++ Imaging Download source code  Open    MISA++ Microbenchmarks Download source code    MISA++ Deconvolution Simulation Download source code    MISA++ Cell Segmentation Download source code    MISA++ OME Download source code  Open    MISA++ OME Visualizer Download source code  Open    MISA++ Tissue Segmentation Download source code  Open    MISA++ Kidney Glomeruli Segmentation Download source code  Open    MISA++ Result Analyzer Download source code  Open    MISA++ for ImageJ Download source code      git clone https://github.com/applied-systems-biology/misaxx-core.git git clone https://github.com/applied-systems-biology/misaxx-imaging.git git clone https://github.com/applied-systems-biology/misaxx-microbench.git git clone https://github.com/applied-systems-biology/misaxx-deconvolve.git git clone https://github.com/applied-systems-biology/misaxx-segment-cells.git git clone https://github.com/applied-systems-biology/misaxx-ome.git git clone https://github.com/applied-systems-biology/misaxx-ome-visualizer.git git clone https://github.com/applied-systems-biology/misaxx-tissue.git git clone https://github.com/applied-systems-biology/misaxx-kidney-glomeruli.git git clone https://github.com/applied-systems-biology/misaxx-analyzer.git git clone https://github.com/applied-systems-biology/misa-imagej.git Linux docker builds We use automated build scripts to compile Linux packages. These scripts use a Docker environment and can be found here.\nWindows Cygwin builds (experimental) To build MISA++ on Windows, we use the Cygwin environment. Our script can be found here.\nLogos Download following package for the MISA++ logos:\nDownload Logos Example data Our step by step guide requires you to download example data:\nDownload example data The example data was published by Klingberg et. al\n Klingberg, Anika, et al. \u0026ldquo;Fully automated evaluation of total glomerular number and capillary tuft size in nephritic kidneys using lightsheet microscopy.\u0026rdquo; Journal of the American Society of Nephrology 28.2 (2017): 452-459.\n Other example data If you want to try out other algorithms (as well as Python and Java implementations), you can find appropriate example data here:\n   Algorithm Download     Glomeruli segmentation (MISA++) Download example data   Glomeruli segmentation (Python, Java) Download example data   Cell segmentation (MISA++) Download example data   Cell segmentation (Python, Java) Download example data   Deconvolution Download example data   Single operation benchamrks Download example data    Publication supplements In our publication, we compare MISA++ against Java and Python implementations. You can find the compiled Java binaries here. All source codes are available in our all-in-one code repository.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/imagej/module-manager/",
	"title": "Managing applications",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/imagej/result-analyzer/table-analyzer/",
	"title": "Summarizing quantification results",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/imagej/analyzing-data/",
	"title": "Analyzing data",
	"tags": [],
	"description": "",
	"content": "\u0026lt;col /\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td style=\u0026quot;border: 1.00pt solid #000000; padding: 0.18cm\u0026quot;\u0026gt;\u0026lt;p \u0026gt; \u0026lt;b\u0026gt;Action\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border: 1.00pt solid #000000; padding: 0.18cm\u0026quot;\u0026gt;\u0026lt;p \u0026gt; \u0026lt;b\u0026gt;Description\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td style=\u0026quot;border: 1.00pt solid #000000; padding: 0.18cm\u0026quot;\u0026gt;\u0026lt;p \u0026gt; \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_25e7e7ae0ee09811.png\u0026quot; name=\u0026quot;image72.png\u0026quot; class=\u0026quot;inline-image\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;  Import parametersImports a compatible parameter file. It will import:Samples (but not the data)Algorithm parametersSample parametersRuntime parametersImport folderImports a folder that contains input data and creates new samples if necessary. The selected folder must follow a specific structure:It must contains sub-folders that represent the samplesThe sample-folders are structured as seen in the “Data” category (see Adding data)If the folder contains a parameters.jsonfile, it will be loaded via the “Import parameters” actionCheck parametersTriggers a manual check of all parameters (see Validating the current settings)ExportExports the current data and parameters into a ready-to-use package for other computers if the current settings are valid (see Validating the current settings). \u0026lt;/p\u0026gt; \u0026lt;p \u0026gt;This will copy all the data into the selected folder. Please make sure that the file system has enough space.\u0026lt;/p\u0026gt; \u0026lt;p \u0026gt;\u0026lt;br/\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p \u0026gt;This will not copy the the MISA++ application itself.\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td style=\u0026quot;border: 1.00pt solid #000000; padding: 0.18cm\u0026quot;\u0026gt;\u0026lt;p \u0026gt; \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_63631d3be680189.png\u0026quot; name=\u0026quot;image60.png\u0026quot; class=\u0026quot;inline-image\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;  RunExecutes the analysis on the current computer. \u0026lt;/p\u0026gt; \u0026lt;p \u0026gt;When the data is successfully analyzed, you can directly analyze the results (see \u0026lt;a href=\u0026quot;#_wuplvgsxnu5l\u0026quot;\u0026gt;\u0026lt;font color=\u0026quot;#1155cc\u0026quot;\u0026gt;\u0026lt;u\u0026gt;Analyzing results\u0026lt;/u\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;/a\u0026gt;).\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td style=\u0026quot;border: 1.00pt solid #000000; padding: 0.18cm\u0026quot;\u0026gt;\u0026lt;p \u0026gt; \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_ef081c2083a666e2.png\u0026quot; name=\u0026quot;image41.png\u0026quot; class=\u0026quot;inline-image\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;  HelpProvides access to the parameter editor documentation and the documentation of the current MISA++ application (Module documentation)\u0026lt;col /\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td style=\u0026quot;border: 1.00pt solid #000000; padding: 0.18cm\u0026quot;\u0026gt;\u0026lt;p \u0026gt; \u0026lt;b\u0026gt;Action\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border: 1.00pt solid #000000; padding: 0.18cm\u0026quot;\u0026gt;\u0026lt;p \u0026gt; \u0026lt;b\u0026gt;Description\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td style=\u0026quot;border: 1.00pt solid #000000; padding: 0.18cm\u0026quot;\u0026gt;\u0026lt;p \u0026gt; \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_60dcc39329925810.png\u0026quot; name=\u0026quot;image11.png\u0026quot; class=\u0026quot;inline-image\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;  Rename sampleAllows you to rename the sample. If the name already exists or is empty, nothing will happen.Remove sampleRemoves the sample\u0026lt;col /\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td style=\u0026quot;border: 1.00pt solid #000000; padding: 0.18cm\u0026quot;\u0026gt;\u0026lt;p \u0026gt; \u0026lt;b\u0026gt;Input data interface element\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border: 1.00pt solid #000000; padding: 0.18cm\u0026quot;\u0026gt;\u0026lt;p \u0026gt; \u0026lt;b\u0026gt;Description\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td style=\u0026quot;border: 1.00pt solid #000000; padding: 0.18cm\u0026quot;\u0026gt;\u0026lt;p \u0026gt; Data type\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border: 1.00pt solid #000000; padding: 0.18cm\u0026quot;\u0026gt;\u0026lt;p \u0026gt; The type of the data.\u0026lt;/p\u0026gt; \u0026lt;p \u0026gt;\u0026lt;br/\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p \u0026gt;\u0026lt;b\u0026gt;Tip\u0026lt;/b\u0026gt;: Hover your mouse over this element to show information about the data type\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td style=\u0026quot;border: 1.00pt solid #000000; padding: 0.18cm\u0026quot;\u0026gt;\u0026lt;p \u0026gt; Name\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border: 1.00pt solid #000000; padding: 0.18cm\u0026quot;\u0026gt;\u0026lt;p \u0026gt; Name of the data. Also acts as internal location within the MISA++ application. \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td style=\u0026quot;border: 1.00pt solid #000000; padding: 0.18cm\u0026quot;\u0026gt;\u0026lt;p \u0026gt; Importer settings\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border: 1.00pt solid #000000; padding: 0.18cm\u0026quot;\u0026gt;\u0026lt;p \u0026gt; User interface specific to the currently selected importer.\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td style=\u0026quot;border: 1.00pt solid #000000; padding: 0.18cm\u0026quot;\u0026gt;\u0026lt;p \u0026gt; Current Importer\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border: 1.00pt solid #000000; padding: 0.18cm\u0026quot;\u0026gt;\u0026lt;p \u0026gt; The importer that provides the data to the MISA++ application.\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt;  \u0026lt;col /\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td style=\u0026quot;border: 1.00pt solid #000000; padding: 0.18cm\u0026quot;\u0026gt;\u0026lt;p \u0026gt; \u0026lt;b\u0026gt;Importer\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border: 1.00pt solid #000000; padding: 0.18cm\u0026quot;\u0026gt;\u0026lt;p \u0026gt; \u0026lt;b\u0026gt;Description\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td style=\u0026quot;border: 1.00pt solid #000000; padding: 0.18cm\u0026quot;\u0026gt;\u0026lt;p \u0026gt; Folder link\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border: 1.00pt solid #000000; padding: 0.18cm\u0026quot;\u0026gt;\u0026lt;p \u0026gt; Supports any data type (is always available) and allows you to select a folder that contains the data.\u0026lt;/p\u0026gt; \u0026lt;p \u0026gt;\u0026lt;br/\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p \u0026gt;Hover your mouse over the \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_dc7ada534948eb26.png\u0026quot; name=\u0026quot;image65.png\u0026quot; class=\u0026quot;inline-image\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;  button to see what kind of files are expected.OME TIFFOnly available if the data type is “OME TIFF”. \u0026lt;/p\u0026gt; \u0026lt;p \u0026gt;Click the \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_b477416cd79efea5.png\u0026quot; name=\u0026quot;image39.png\u0026quot; class=\u0026quot;inline-image\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt; button to show possible image sources. If there are images loaded in ImageJ, you can import an \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_ff434d5cde2d1747.png\u0026quot; name=\u0026quot;image58.png\u0026quot; class=\u0026quot;inline-image\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;  image directly from ImageJ."
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/citation/",
	"title": "Citation",
	"tags": [],
	"description": "",
	"content": "Please cite following publication if you use our framework:\nGerst, R., Medyukhina, A., \u0026amp; Figge, M. T. (2020). MISA++: A standardized interface for automated bioimage analysis. SoftwareX, 11, 100405.\nhttps://doi.org/10.1016/j.softx.2020.100405\n Thanks!\nThe MISA++ framework was developed by Research Group Applied Systems Biology - Head: Prof. Dr. Marc Thilo Figge\nHKI-Center for Systems Biology of Infection\nLeibniz Institute for Natural Product Research and Infection Biology - Hans Knöll Insitute (HKI)\nAdolf-Reichwein-Straße 23, 07745 Jena, Germany\n "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/imagej/result-analyzer/plot-builder/",
	"title": "Creating plots",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/development/creating-tasks/",
	"title": "Creating tasks",
	"tags": [],
	"description": "",
	"content": "The MISA++ framework manages workloads by parallelized execution of atomic tasks. Additionally, dispatchers can be created that acts as inner node within a tree of workers. Tasks on the other hand are always leaves.\nThe module dispatcher (./include/\u0026lt;module-name\u0026gt;/module.h) acts as root of this tree and as entry point to define the tasks that process data and their dependencies.\nTasks contain atomic workloads that should be able to run in parallel. All tasks inherit from misaxx::misa_task and require you to inherit following methods:\nvoid create_parameters(misaxx::misa_parameter_builder \u0026amp;parameters); void work(); The create_parameters() function comes with a parameter builder and allows you to create misaxx::misa_parameter\u0026lt;T\u0026gt; instances. The work() function is called when the work should be executed.\nCreating parameters To be able to automatically generate the parameter schema, the MISA++ framework requires you to initialize parameters within the create_parameters(...) function.\nExamplestruct my_task : public misa_task { using misa_task::misa_task; parameter\u0026lt;int\u0026gt; m_radius; void create_parameters(misaxx::misa_parameter_builder \u0026amp;parameters) { m_radius = parameters.create_algorithm_parameter\u0026lt;int\u0026gt;(\u0026#34;radius\u0026#34;, 10); // Will be independent of the current sample  } }  There are 3 types of parameters that are available:\n   Type Parameter.json path Description     Algorithm /algorithm/../..* Independent from current sample. Depends on name and path of current worker   Sample /samples/(current sample)/* Only depends on sample name.   Runtime /runtime/* Global    Accessing data Data is accessed via the module interface, or alternatively via cache accessor member variables. Access to the current module interface is available via the get_module() and get_module_as\u0026lt;T\u0026gt;() functions. This applies to all workers (tasks and dispatchers).\nExamplestruct my_task : public misa_task { using misa_task::misa_task; void work() { misaxx::ome::misa_ome_tiff tiff = get_module_as\u0026lt;my_module_interface\u0026gt;()-\u0026gt;m_input_data; // Do something with tiff  } }  "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/standards/",
	"title": "Standards",
	"tags": [],
	"description": "",
	"content": "The MISA++ framework defines various standards that make development of custom modules easier and allow fully automated interaction between MISA++ applications and external tools.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/imagej/result-analyzer/runtime-log/",
	"title": "Analyzing the runtime",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/development/creating-dispatchers/",
	"title": "Creating dispatchers",
	"tags": [],
	"description": "",
	"content": "The MISA++ framework manages workloads by parallelized execution of atomic tasks. Additionally, dispatchers can be created that acts as inner node within a tree of workers. Tasks on the other hand are always leaves.\nThe module dispatcher (./include/\u0026lt;module-name\u0026gt;/module.h) acts as root of this tree and as entry point to define the tasks that process data and their dependencies.\nDispatchers require you to override following virtual functions:\nvoid create_blueprints(misa_dispatcher::blueprint_list \u0026amp;blueprints, misa_dispatcher::parameter_list \u0026amp;parameters); void build(const misa_dispatcher::blueprint_builder \u0026amp;builder); To allow the automated documentation of the whole tree of tasks, the misaxx::misa_dispatcher interface requires a data-independent declaration of all sub-dispatchers and tasks that the dispatcher might create, as well as all parameters that might be queried from the parameter file.\nThe function that defines all those available options is create_blueprints(...). After defining all possible tasks, sub-dispatchers and parameters, you can use them within the build(...) function.\nPlease keep in mind that create_blueprints(...) can be run in simulation mode (to acquire the parameter schema), which means that you should not query data or parameters from within the function without checking misaxx::runtime_properties::is_simulating().\n Creating and instantiating blueprints A \u0026ldquo;possible task/dispatcher\u0026rdquo; is called a blueprint and defined within the create_blueprints(...) function. The dispatcher class offers the create_blueprint\u0026lt;T\u0026gt;(...) method that creates such a blueprint. T can be any non-module dispatcher or task. The created blueprint must be added to the blueprint list to activate it.\nBlueprints are instantiated within the build(...) function by using the T \u0026amp;misa_dispatcher::blueprint_builder::build\u0026lt;T\u0026gt;() function.\nExamplevoid module::create_blueprints(misa_dispatcher::blueprint_list \u0026amp;blueprint_list, misa_dispatcher::parameter_list \u0026amp;parameters) { blueprint_list.add(create_blueprint\u0026lt;my_task\u0026gt;(\u0026#34;my-task\u0026#34;)); // Announces a task \u0026#34;my-task\u0026#34;  create_blueprint\u0026lt;my_task\u0026gt;(\u0026#34;wrong\u0026#34;); // WRONG: Forgot to add it to the blueprint list } void module::build(const misa_dispatcher::blueprint_builder \u0026amp;builder) { builder.build\u0026lt;my_task\u0026gt;(\u0026#34;my-task\u0026#34;); // Instantiates a my_task \u0026#34;my-task\u0026#34;  builder.build\u0026lt;my_task\u0026gt;(\u0026#34;my-task\u0026#34;); // Can be done multiple times  builder.build\u0026lt;unregistered_task\u0026gt;(\u0026#34;wrong2\u0026#34;); // ERROR: Task is not registered  builder.build\u0026lt;unregistered_task\u0026gt;(\u0026#34;my-task\u0026#34;); // ERROR: \u0026#34;my-task\u0026#34; cannot be converted into unregistered_task  my_task_base \u0026amp;task = builder.build\u0026lt;my_task_base\u0026gt;(\u0026#34;my-task\u0026#34;); // NO error: If my_task inherits from my_task_base }  Instantiating workers does not mean that their work is executed. Instantiation only registers them into the runtime for later processing.\n Dependency management Instantiating a worker with build is sufficient if there are no dependencies between workers. If dependencies are required, dispatchers provide functionality to create dependencies between workers. The framework runtime automatically ensures that those dependencies are satisfied.\nYou can use following classes to easily define dependencies:\nmisaxx::misa_dispatcher::group misaxx::misa_dispatcher::chain Groups A group can be used to group workers together. It has two operators \u0026lt;\u0026lt; and \u0026gt;\u0026gt; that allow adding workers to the group and assigning the group as dependency of another worker.\nExamplevoid module::build(const misa_dispatcher::blueprint_builder \u0026amp;builder) { group parallelized; for (int i = 0; i \u0026lt; 3; ++i) { parallelized \u0026lt;\u0026lt; builder.build\u0026lt;A\u0026gt;(\u0026#34;A\u0026#34;); } parallelized \u0026gt;\u0026gt; builder.build\u0026lt;B\u0026gt;(\u0026#34;B\u0026#34;); }  The example builds a group of 3 tasks that have no specific order (they can be run in parallel) and another task that waits until all 3 tasks are finished. This is the dependency graph that is created: mermaid.initialize({startOnLoad:true}); graph TD A0[\"A\"]--B A1[\"A\"]--B A2[\"A\"]--B \nChains A chain allows easy creation of chain-dependencies. It only has a \u0026gt;\u0026gt; operator, but can be initialized with a set of dependencies.\nExamplevoid module::build(const misa_dispatcher::blueprint_builder \u0026amp;builder) { group parallelized; for (int i = 0; i \u0026lt; 3; ++i) { parallelized \u0026lt;\u0026lt; builder.build\u0026lt;A\u0026gt;(\u0026#34;A\u0026#34;); } chain pipe {{ parallelized }}; pipe \u0026gt;\u0026gt; builder.build\u0026lt;B\u0026gt;(\u0026#34;B\u0026#34;) \u0026gt;\u0026gt; builder.build\u0026lt;C\u0026gt;(\u0026#34;C\u0026#34;) \u0026gt;\u0026gt; builder.build\u0026lt;D\u0026gt;(\u0026#34;D\u0026#34;); }  The example builds a group of 3 tasks that have no specific order (they can be run in parallel) and a chain of other tasks that are run strictly one-after-another. This is the dependency graph that is created:\nmermaid.initialize({startOnLoad:true}); graph TD; A0[\"A\"]--B; A1[\"A\"]--B; A2[\"A\"]--B; B--C; C--D;  "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/imagej/creating-pipelines/",
	"title": "Creating pipelines",
	"tags": [],
	"description": "",
	"content": "\u0026lt;col /\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;b\u0026gt;Component\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;b\u0026gt;Description\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; Name\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; The name of the processing step.\u0026lt;/p\u0026gt; \u0026lt;p \u0026gt;Can be edited.\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; Description\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; Optional description of the processing step. Can be edited.\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_339b3b21fe54de67.png\u0026quot; name=\u0026quot;image26.png\u0026quot; class=\u0026quot;inline-image\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;  Connect from other nodeClick to connect another processing step to the current one.This button is not visible if there are no available connections.Remove entryRemoves the processing step.Edit parametersOpens a parameter editor (see Analyzing data) for the MISA++ application behind the processing step.Arrow(s) and Remove connectionAn arrow connects the data from one application to another. Click Remove connection to remove the connection.\u0026lt;col /\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;b\u0026gt;Action\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;b\u0026gt;Description\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_339b3b21fe54de67.png\u0026quot; name=\u0026quot;Image2\u0026quot; class=\u0026quot;inline-image\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;  Synchronize selectedEnsures that the selected samples are represented in the same set of processing steps. \u0026lt;/p\u0026gt; \u0026lt;p \u0026gt;\u0026lt;u\u0026gt;Example\u0026lt;/u\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p \u0026gt;We have following configuration:\u0026lt;/p\u0026gt; \u0026lt;p \u0026gt;\u0026lt;br/\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;table cellpadding=\u0026quot;7\u0026quot; cellspacing=\u0026quot;0\u0026quot;\u0026gt; \u0026lt;col /\u0026gt; \u0026lt;col /\u0026gt; \u0026lt;col /\u0026gt; \u0026lt;col /\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;br/\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; Sample1\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; Sample2\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; Sample3\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; Step 1\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;br/\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; ✓\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;br/\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; Step 2\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; ✓\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; ✓\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;br/\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; Step 3\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;br/\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; ✓\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; ✓\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;p \u0026gt; \u0026lt;br/\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p \u0026gt; If we synchronize Sample 1 and Sample 3, both of them will be in Step 2 and Step 3, but not Step 1. \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_339b3b21fe54de67.png\u0026quot; name=\u0026quot;Image3\u0026quot; class=\u0026quot;inline-image\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;  AutosyncIf enabled (default), keeps samples synchronized across all processing steps.\u0026lt;col /\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; Action\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; Description\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_b477416cd79efea5.png\u0026quot; name=\u0026quot;image113.png\u0026quot; class=\u0026quot;inline-image\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;  OpenOpens a pipeline description file.Please note that while structure of the pipeline and its connections are imported, all non-pipeline input data (from outside sources such as ImageJ) must be manually set after loading the pipeline.SaveSaves the structure of the pipeline, includingThe processing stepsSamplesAlgorithm parametersSample parametersRuntime parametersPipeline connections (including importer settings)This will not save importer settings for non-pipeline data sources.Check parametersManually triggers a check if the settings of each processing step are correct. See Validating the current pipeline settingsfor more information.ExportExports a ready-to-use package that processes the pipeline. The packages require that the MISA++ applications are installed on the current computer and includes all settings, parameters and data. \u0026lt;/p\u0026gt; \u0026lt;p \u0026gt;The tool generates two feature-identical scripts \u0026lt;i\u0026gt;run.sh\u0026lt;/i\u0026gt; (Linux) and \u0026lt;i\u0026gt;run.py\u0026lt;/i\u0026gt; (any operating system) and saves the pipeline structure in\u0026lt;i\u0026gt; pipeline.json\u0026lt;/i\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;td \u0026gt;\u0026lt;p \u0026gt; \u0026lt;img src=\u0026quot;/img/imagej/userguide_html_63631d3be680189.png\u0026quot; name=\u0026quot;image44.png\u0026quot; class=\u0026quot;inline-image\u0026quot; border=\u0026quot;0\u0026quot;/\u0026gt;  RunExecutes the pipeline on the current computer.HelpOpens the documentation."
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/glossary/",
	"title": "Glossary",
	"tags": [],
	"description": "",
	"content": "MISA++ application Application that uses the MISA++ CLI to create an executable from a MISA++ worker module.\nMISA++ worker module A MISA++ module that contains a module dispatcher, a module interface and a module info function.\nMISA++ module A library that follows the MISA++ public API standard and is built on MISA++ Core.\nModule interface A class that inherits from misaxx::misa_module_interface and is part of the public API of the module.\nModule dispatcher A class that inherits from misaxx::misa_module and is part of the public API of the module.\nModule info A function module_info() in the namespace of the MISA++ module that returns a misaxx::misa_module_info instance (see Module Info).\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/imagej/result-analyzer/",
	"title": "Analyzing results",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/references/",
	"title": "Class reference",
	"tags": [],
	"description": "",
	"content": "   Library Class reference     MISA++ Core Open    MISA++ Imaging Open    MISA++ OME Open    MISA++ OME Visualizer Open    MISA++ Tissue Segmentation Open    MISA++ Kidney Glomeruli Segmentation Open    MISA++ Result Analyzer Open     "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/development/dispatching-submodules/",
	"title": "Dispatching submodules",
	"tags": [],
	"description": "",
	"content": "You reduce the amount of code in your current project by off-loading work to another MISA++ module. The sub-module will be integrated into the current worker tree and benefit from better parallelization and less post-processing compared to running MISA++ applications in a pipeline.\nPrerequisites Modify the CMakeLists.txt and the cmake/*-config.in to add the submodule as dependency.\nExampleIn CMakeLists.txt find_package(misaxx-core REQUIRED)find_package(misaxx-tissue-segmentation REQUIRED)# Later: target_link_libraries(my-module PUBLIC misaxx::misaxx-tissue-segmentation)In cmake/*-config.in find_package(misaxx-core REQUIRED)find_package(misaxx-tissue-segmentation REQUIRED) Submodules within the filesystem A submodule is created on a subfolder of the current virtual filesystem and therefore are handled similar to data. The name of the folder is set during the declaration of the submodule in a dispatcher\u0026rsquo;s create_blueprints function.\nmermaid.initialize({startOnLoad:true}); graph TD Main[\"main() root module\"] Main -- S1[\"Current module (Sample 1)\"] Main -- S2[\"Current module (Sample 2)\"] S1 -- D1(\"Data 1\") S1 -- D2(\"Data 2\") S2 -- D3(\"Data 1\") S2 -- D4(\"Data 2\") S1 == M1[\"Submodule\"] S2 == M2[\"Submodule\"]   Please do not name sub-modules like existing data. This also means that the name of a submodule must be unique across the whole module.\nThis does not apply to submodules of the submodules, as each sub-module gets its own virtual filesystem.\n Submodules are independent of the dispatcher where they are instantiated. They only depend on the filesystem of the instantiating module.\n Dispatching a submodule It is recommended to add submodules to the module interface. To do this, create an empty shared pointer to the submodule interface in the current module interface.\nstruct module_interface : public misaxx::misa_module_interface { std::shared_ptr\u0026lt;my_submodule::module_interface\u0026gt; m_submodule; } Instantiate the pointer within the setup() function (see Creating dispatchers). Here you can also pass input data from the current module to the submodule.\nvoid setup() { m_submodule = std::make_shared\u0026lt;my_submodule::module_interface\u0026gt;(); // You have the option to directly set the input data of the submodule  m_submodule.m_input_images = this-\u0026gt;m_input_images; } Like all dispatchers, submodules need to be added to the list of blueprints. It is recommended to do this in the module dispatcher. Use create_submodule_blueprint(...) instead of create_blueprint(...).\nThe create_submodule_blueprint(...) function requires you to give a name to the submodule and allows you to pass the submodule interface that was created within the module interface. The shared pointer will be automatically updated to follow the submodule dispatcher instead.\nmodule::create_blueprints(misa_dispatcher::blueprint_list \u0026amp;blueprints, misa_dispatcher::parameter_list \u0026amp;parameters) { blueprints.add(create_submodule_blueprint\u0026lt;my_submodule::module\u0026gt;(\u0026#34;my-submodule\u0026#34;, get_module_as\u0026lt;module_interface\u0026gt;()-\u0026gt;m_submodule)); } Dispatch the submodule dispatcher just like any other dispatcher (see Creating dispatchers).\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/development/attaching-data/",
	"title": "Attaching data",
	"tags": [],
	"description": "",
	"content": "The attachment system allows easy attachment of any serializable data to a cache. It can be used to communicate between different tasks and generate quantification output. If the attachment data type supports adding information about its location (e.g. which image plane), the cache will automatically assign the most available information.\nAttaching data to a cache To attach data, just call the void attach\u0026lt;T\u0026gt;(...) member function of a cache accessor. To access an attachment, you can use the T \u0026amp;get\u0026lt;T\u0026gt;() member function, which will throw an exception if the type does not exist. Use the T \u0026amp;access\u0026lt;T\u0026gt;() function to either return an existing attachment or create a new one.\nAttachments are caches and therefore thread-safe.\nExample void my_task::work() { auto module = get_module_as\u0026lt;module_interface\u0026gt;(); module-\u0026gt;m_output.attach(my_attachment(\u0026#34;important\u0026#34;)); module-\u0026gt;m_output.get\u0026lt;not_in_output\u0026gt;(); // Throws an exception  module-\u0026gt;m_output.access\u0026lt;not_in_output\u0026gt;().important_stuff = true; // Safe access } Creating a new attachment type Attachments inherit either from misaxx::misa_serializable or misaxx::misa_locatable. If you want a plain attachment, use misaxx::misa_serializable as base. The misaxx::misa_locatable interface additionally allows adding a location to the attachment. This location allows easy assignment of the data to the data its attached to.\nAny MISA++ serializable must override following virtual methods:\nvoid from_json(const nlohmann::json \u0026amp;j); void to_json(nlohmann::json \u0026amp;j) const; void to_json_schema(misaxx::misa_json_schema_property \u0026amp;t_schema) const; void build_serialization_id_hierarchy(std::vector\u0026lt;misaxx::misa_serialization_id\u0026gt; \u0026amp;result) const; You additionally need to create following inline functions that are needed for JSON serialization.\ninline void to_json(nlohmann::json \u0026amp;j, const my_attachment \u0026amp;p) { p.to_json(j); } inline void from_json(const nlohmann::json \u0026amp;j, my_attachment \u0026amp;p) { p.from_json(j); } The from_json and to_json members should be used to serialize or deserialize the object. The to_json_schema describes the JSON that is created/expected by the from_json and to_json members and is used to generate the parameter schema.\nEach serializable is assigned an unique serialization id. The build_serialization_id_hierarchy is used to create this ID.\nFrom and to JSON Just take a look at the JSON for Modern C++ documentation.\nDescribing the input and output JSON To be able to create the parameter schema, each serialzable object must describe the expected structure of the serialized JSON. The misaxx::misa_json_schema provides methods to do this.\nIt offers following methods:\n declare\u0026lt;T\u0026gt;(...) declares the current path as JSON of type T. The default value is the T() declare_optional\u0026lt;T\u0026gt;(...) allows providing a default value declare_required\u0026lt;T\u0026gt;(...) marks the property as a required property resolve() returns a sub-path of the current JSON schema path. It will create a child property if needed  Please keep in mind that the provided misaxx::misa_json_schema_property represents the \u0026ldquo;root\u0026rdquo; of the current JSON object. This means that you have to call the declare function on resolve(...) to register member variables.\nPortable serialization Each serializable type has an unique serialization id of type misaxx::misa_serialization_id. This id is part of a hierarchy of serialization ids that mirrors the inheritance hierarchy of the C++ class. This allows external programs to serialize even unsupported types with minimal loss of information.\nThe build_serialization_id_hierarchy is used to build this hierarchy. In most cases, it is sufficient to just add the serialization ID of the current class to the list of IDs provided in the parameter.\n Please do not forget to call build_serialization_id_hierarchy function of the parent class.\n Serialization IDs have two components:\n The module A path that describes the serialized object  The serialization ID should be consistent with the location in the public interface, which means that it should for example be misa_serialization_id(\u0026quot;my-module\u0026quot;, \u0026quot;attachments/my-attachment\u0026quot;.\nExample/** * We want this attachment to be assignable to a cache after the program has run. * Alternatively use misa_serializable */ struct my_attachment : public misaxx::misa_locatable { int count = 0; std::vector\u0026lt;double\u0026gt; variances; bool some_flag = false; void from_json(const nlohmann::json \u0026amp;j) { // As usual with nlohmann::json  count = j[\u0026#34;count\u0026#34;]; variances = j[\u0026#34;variances\u0026#34;].get\u0026lt;std::vector\u0026lt;double\u0026gt;\u0026gt;(); // An optional parameter:  if(j.find(\u0026#34;some-flag\u0026#34;) != j.end()) some_flag = j[\u0026#34;some-flag\u0026#34;]; } void to_json(nlohmann::json \u0026amp;j) const { // As usual with nlohmann::json  j[\u0026#34;count\u0026#34;] = count; j[\u0026#34;variances\u0026#34;] = variances; j[\u0026#34;some-flag\u0026#34;] = some_flag; } void to_json_schema(const misaxx::misa_json_schema \u0026amp;t_schema) const { // The schema is at the \u0026#34;root\u0026#34; of the object.  // This is for example helpful if you want to wrap a single value  // e.g. t_schema.declare_required\u0026lt;int\u0026gt;();  // if we read/write like this: this-\u0026gt;value = j; in from_json  // But we have member functions, so we need to use \u0026#34;resolve\u0026#34;  // Short and efficient for \u0026#34;count\u0026#34;:  t_schema.resolve(\u0026#34;count\u0026#34;).declare_required\u0026lt;int\u0026gt;(); // No additional info. This is sufficient  // some_flag is optional, so use the other method  t_schema.resolve(\u0026#34;some-flag\u0026#34;).declare_optional\u0026lt;bool\u0026gt;(false); // Default is false  // Use misa_json_property for extra fun  t_schema.resolve(\u0026#34;variances\u0026#34;).declare(misa_json_property\u0026lt;std::vector\u0026lt;double\u0026gt;\u0026gt;() .make_optional() .with_title(\u0026#34;Variances\u0026#34;) .with_description(\u0026#34;Optional variances\u0026#34;)); } void build_serialization_id_hierarchy(std::vector\u0026lt;misaxx::misa_serialization_id\u0026gt; \u0026amp;result) const { // Please do not forget to call the parent build_serialization_id_hierarchy() method!  misaxx::misa_locatable::build_serialization_id_hierarchy(result); // Add our own ID now  result.emplace_back(misaxx::misa_serialization_id(\u0026#34;my-module\u0026#34;, \u0026#34;attachments/my-attachment\u0026#34;)); } } // Important for nlohmann:json serialization // Do not forget them inline void to_json(nlohmann::json \u0026amp;j, const my_attachment \u0026amp;p) { p.to_json(j); } inline void from_json(const nlohmann::json \u0026amp;j, my_attachment \u0026amp;p) { p.from_json(j); }  "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/credits/",
	"title": "Credits",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/imagej/credits/",
	"title": "Credits",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/development/creating-caches/",
	"title": "Creating caches",
	"tags": [],
	"description": "",
	"content": "This guide will show you how to create your own cache types. A cache data type consists of four different classes:\n The cache implementation The cache accessor A pattern A description  The cache implementation is responsible for dynamically loading and unloading data from/to a folder that is located within the filesystem. Such a folder on the other hand can contain many different files with different names, while an image file cache would for example look for a specific image file within this folder.\nInstead of cache-specific functions like a set_file(path) function, a description is used as input of a cache. It uses this description to set all internal parameters to function correctly. Descriptions are serializable, making them portable. The describe() function of a cache allows access to this description and implementation-independent modification of its values. This enables easy derivation of exported data from imported data.\nA description on the other hand just contains already defined parameters (like for example the filename), which does not solve the issue of caches containing vastly different files. Patterns are objects with the purpose of creating a description from its a folder in a filesystem.\nA cache accessor is a shared-pointer-like object with the purpose of allowing easy access to the functionality of a cache. You can use it to add convenient methods that make it easier to work with the specific cache type.\nThe module interface and workers access a cache only via a cache accessor.\n mermaid.initialize({startOnLoad:true}); graph TD; Pattern--|Produce|Description Description--|Link|Cache Cache--|Describe|Description Filesystem--|Produce|Description Accessor--|Access|Cache Accessor-.-I[\"Module interface\"]  The base types of the necessary cache components are:\n misaxx::misa_cache and any of misaxx::utils::access::cache for caches misaxx::misa_cached_data for accessors misaxx::misa_data_pattern for patterns misaxx::misa_data_description for desciptions  Creating the cache implementation We first show you to use our misaxx::misa_default_cache helper that automates many functions that you would need to define manually.\nThe misaxx::misa_default_cache helper requires three template arguments:\n A mutexed cache of type misaxx::utils::access::cache or misaxx::utils::access::memory_cache The pattern type The description type   Please make sure to create a cache-specific description type. This is needed to later identify the cache type. Optional for the pattern type.\n The mutexed cache is a utility type that models the actual read and write access of the cache implementation. If you create a cache with a small enough footprint that allows it to be stored within memory, you can use misaxx::utils::access::memory_cache instead.\nLinking, Simulating and Postprocessing The misaxx::misa_default_cache requires you to override following functions:\nDescription produce_description(const boost::filesystem::path \u0026amp;, const Pattern \u0026amp;); void do_link(const \u0026lt;Description\u0026gt; \u0026amp;t_description); void simulate_link(); // Optional void postprocess() // Optional The produce_description() function is responsible for creating applying the pattern and generating a description that allows the link function to find all necessary data within the folder.\nThe main link function is do_link(). It takes the description type of the cache and allows you to setup all internal functionality to make reading and writing work. It is only called if the runtime is not creating a parameter schema.\nIf a parameter schema is created, simulate_link() is called instead. By default, it will ensure that describe() returns a storage that contains both the pattern and description type. If you want to add additional information, just override this method.\nExample // The parameter schema will have the information that the pattern looks for JSON files void my_cache::simulate_link() { describe()-\u0026gt;set(misa_file_pattern({ \u0026#34;.json\u0026#34; })); describe()-\u0026gt;access\u0026lt;misa_file_description\u0026gt;(); } Postprocessing The postprocess() method will be called after the runtime has finished all tasks you can use it to clean up the cache or finalize the output.\nLocation and unique location A cache always has a location that corresponds to the location provided in the link function. It is automatically set by the default cache.\nAdditionally, there is an unique location that should always point to some file within the cache\u0026rsquo;s location folder (use get_location() to obtain it). Please do not forget to set this unique location using set_unique_location() somewhere in do_link()\nSub-caches You can define sub-caches that are manually linked during do_link(). Just make sure that their location is equal to the location of the main cache and that their unique location is unique.\nThread-safe data access A cache implementation always inherits from a mutexed cache of type misaxx::utils::access::cache. It will require you to override following methods as well:\nT \u0026amp;get() override; const T \u0026amp;get() const override; void set(T value) override; bool has() const override; bool can_pull() const override; void pull() override; void stash() override; void push() override; The get and set functions do what you would expect. pull() is responsible for loading data into memory, while push() is responsible for writing the current data to files on the harddrive. push() should not clear the data. stash() will be called to do only this if necessary. can_pull() should return if loading is possible (e.g. if the file exists).\nAll methods are called from a thread-safe environment using a shared mutex:\n   Function Access     get shared   has shared   can_pull shared   pull exclusive   stash exclusive   push exclusive    Do not call get(), has(), etc. manually unless you know exactly what you do. Use readonly_access(), write_access() and readwrite_access() that are provided by the accessor!\n The cache accessor A cache accessor is a shared pointer to a cache implementation. It contains additional functions to interact with the cache.\nJust inherit from misa_cached_data\u0026lt;CacheImplementation\u0026gt;. You can also inherit from misa_description_accessors_from_cache\u0026lt;CacheImplementation, SELF\u0026gt; to automatically add convenient access to caches that are based on misa_default_cache.\nExampleWe will create a cache that provides access to an integer. It will be stored in a file, so it is sufficient to just use a file pattern and derive our description from misa_file_description.\nThe pattern /** patterns/integer_pattern.h */ struct integer_pattern : public misaxx::misa_file_pattern { // We only look for .integer files  integer_description() : misaxx::misa_file_pattern({ \u0026#34;.integer\u0026#34; }) { } protected: void build_serialization_id_hierarchy(std::vector\u0026lt;misa_serialization_id\u0026gt; \u0026amp;result) const override; } inline void to_json(nlohmann::json\u0026amp; j, const integer_pattern\u0026amp; p); inline void from_json(const nlohmann::json\u0026amp; j, integer_pattern\u0026amp; p); The description /** descriptions/integer_description.h */ struct integer_description : public misaxx::misa_file_description { using misa_file_description::misa_file_description; protected: void build_serialization_id_hierarchy(std::vector\u0026lt;misa_serialization_id\u0026gt; \u0026amp;result) const override; } inline void to_json(nlohmann::json\u0026amp; j, const integer_description\u0026amp; p); inline void from_json(const nlohmann::json\u0026amp; j, integer_description\u0026amp; p); The cache implementation /** caches/integer_cache.h */ struct integer_cache : public misaxx::misa_default_cache\u0026lt; misaxx::utils::access::cache\u0026lt;int\u0026gt;, integer_pattern, integer_description\u0026gt; { // Inherited from mutexed cache. Just plain I/O  int \u0026amp;get() { return m_value.get(); } const int \u0026amp;get() const { return m_value.get(); } void set(int v) { m_value = v; } bool has() const { return m_value.has_value(); } bool can_pull() const { return boost::filesystem::exists(m_path); } void stash() { m_value = std::nullopt; } void pull() { std::ifstream r; r.open(m_path.string()); int v; r \u0026gt;\u0026gt; v; m_value = v; } void push() { std::ofstream w; w.open(m_path.string()) w \u0026lt;\u0026lt; m_value.get(); } // Linkage, simulation \u0026amp; postprocessing protected: integer_description produce_description(const boost::filesystem::path \u0026amp;path, const integer_pattern \u0026amp;pattern) override { integer_description description; pattern.apply(description, path); // Functionality of misa_file_pattern  return description; } public: void do_link(const integer_description \u0026amp;description) override { // Just take the filename in this case  m_path = get_location() / description.filename; // VERY IMPORTANT  set_unique_location(m_path); } void postprocess() override { std::cout \u0026lt;\u0026lt; \u0026#34;Nothing\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } private: boost::filesystem::path m_path; std::optional\u0026lt;int\u0026gt; m_value; } Cache accessor /** accessors/integer.h */ struct integer : public misaxx::misa_cached_data\u0026lt;integer_cache\u0026gt; { using misaxx::misa_cached_data\u0026lt;integer_cache\u0026gt;::misa_cached_data; // We add some additional functions for convenience  int get() const { auto access = readonly_access(); return access.get(); } void set(int value) { auto access = write_access(); access.set(value); } }  Sub-caches You can create sub-caches that allow access to individual parts of the data. They live within the same filesystem location and are linked in the do_link() method of the main cache.\nTo make it easier, we provide the misaxx::manual_cache type that can be used as base instead of misaxx::default_cache. It provides the same functionality, but does not require a pattern. Instead, the main cache should provide a valid description.\nIn the do_link() method, create an uninitialized accessor type of the sub-cache and set its data attribute manually. Then run force_link with the appropriate arguments. This will ensure that the sub-cache is registered correctly.\nExamplevoid do_link(integer_description \u0026amp;description) override { decimals accessor; accessor.data = std::make_shared\u0026lt;decimals_cache\u0026gt;(); // Manual setup etc.  // Important:  decimal_description subcache_description; accessor.force_link(this-\u0026gt;get_location(), misa_description_storage::with(subcache_description)); // Store for later usage  this-\u0026gt;decimals = std::move(accessor); }  Without using misa_default_cache A cache implementation should inherit from misaxx::misa_cache and a mutexed cache (misaxx::utils::access::cache). It should override following methods:\n// Main function that applies the linkage process: void link(const boost::filesystem::path \u0026amp;t_location, const std::shared_ptr\u0026lt;misa_description_storage\u0026gt; \u0026amp;t_description); // Returns the pattern \u0026amp; description: std::shared_ptr\u0026lt;misa_description_storage\u0026gt; describe() const; // The absolute folder path where the data is located boost::filesystem::path get_location() const; // A filename or any other unique file (for an explanation see below) boost::filesystem::path get_unique_location() const; // Returns true if the cache has currently data bool has_data(); // Returns a \u0026#34;self-description\u0026#34; of the cache location std::shared_ptr\u0026lt;const misa_location\u0026gt; get_location_interface() const // Optionally: Run after all work is done void postprocess() // Additional methods might be necessary depending on the mutexed cache implementation The link() method is provided with an absolute path within the filesystem and a description. The link() function is called independent of the simulation mode. This means you have to use misaxx:runtime_properties::is_simulating() to check if the runtime is actually processing data.\nPlease make sure that describe() always returns a non-empty description storage with both a pattern and description. This also applies for parameter schema generation.\n "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/development/tips/",
	"title": "Tips and tricks",
	"tags": [],
	"description": "",
	"content": "Interacting with the runtime The MISA++ runtime is responsible for managing parameters, generation of the parameter schema, managing caches and executing workers.\nThere are multiple interface functions avilable that allow extracting information from and manipulation of the runtime.\nmisaxx::runtime_properties Contains functions about the current set of workers, the number of threads, the root filesystem and information about the root module.\nThe most important function is misaxx::runtime_properties::is_simulating() that indicates if actual work should be done or a parameter schema is currently being generated.\nmisaxx::cache_registry Allows manual registration and de-registration of caches.\nmisaxx::parameter_registry Allows manual query of parameters, access to the parameter JSON data and parameter schema builder.\nWorking on streaming data MISA++ can be used to process that that is not (yet) fully present on the hard disk, but generated during the runtime. This is for example helpful for online analyses.\nA possible way is to implement a cache that acts as data source and offers functionality to query data that should be processed and a way to know if the analysis should be finished.\nAny MISA++ worker (tasks, dispatchers and module dispatchers) allows repetition of the workload. This does not include the parameter and blueprint generation. This functionality can be used to create new workers whenever new data is available.\nvoid create_blueprints(blueprint_list \u0026amp;blueprints, parameter_list \u0026amp;parameters) { blueprints.add(create_blueprint\u0026lt;online_analysis_dispatcher\u0026gt;(\u0026#34;online-analysis\u0026#34;)); } void build(const blueprint_builder \u0026amp;builder) { while(m_input_stream.has_new_data()) { online_analysis_dispatcher \u0026amp;worker = builder.build\u0026lt;online_analysis_dispatcher\u0026gt;(\u0026#34;online-analysis\u0026#34;); worker.m_input = m_input_stream.dequeue(); } if(!m_input_stream.is_finished()) { this-\u0026gt;repeat_work(); } } "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/_footer/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "By Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans Knöll Institute (HKI), Jena, Germany\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/standards/attachments/",
	"title": "Attachments",
	"tags": [],
	"description": "",
	"content": "MISA++ comes with a system to attach quantification results and other information to input and output data. The information is stored within objects that are serialized into JSON format, including additional information such as the object type.\nAttachments are saved in the attachments/imported and attachments/exported folders within a MISA++ result folder. The files are structured according to the filesystem (see Parameters).\nAn attachment file has the following structure:\nmermaid.initialize({startOnLoad:true}); graph LR; Root[\"root : object\"]--|for each attachment|A[\" : misa-serializable\"] Root -- RootL[location : misa-location] S[misa-serializable : object] S -- Sid[misa:serialization-id : string] S -- Shierarchy[misa:serialization-hierarchy : array of string] S -.- O[\"Other properties\"] L[misa-location : misa-serializable] L -- FsLocation[filesystem-location : string] L -- FsULocation[filesystem-unique-location : string] L -- FsILocation[internal-location : string] L -.- O2[\"Other properties\"]  root The root of an attachment file is a JSON object that maps from misa:serialization-id to the attached object. It has an additional entry location that maps to a misa:location.\nmisa-serializable misa:serialization-id Unique identifier of the object type. Follows the Serialization ID standard.\nmisa:serialization-hierarchy A list of strings the describes the inheritance hierarchy of the object. The first entry is always misa:serializable. The last entry is always the current misa:serialization-id. The hierarchy is ordered from the most basic type to the current one.\nmisa-location Inherits all properties from misa:serializable.\nfilesystem-location Absolute path of the folder that contains the input or output data. Different parts of the data have the same filesystem-location.\nfilesystem-unique-location Absolute path to a file or folder within the the filesystem-location. Unique for each part of the data.\ninternal-location Internal MISA++ filesystem location.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/building/building-linux/",
	"title": "Building on Linux",
	"tags": [],
	"description": "",
	"content": "This building guide was tested for Ubuntu 18.04 and 19.10. To build *.deb packages, you can alternatively use our Docker-based Linux build scripts. We also provide generic Linux build scripts that should work for any Linux distribution, given that the dependencies are installed.\nDue to the differences between different Linux distributions, we cannot guarantee that the generic build script runs without error.\n Building the C++ framework MISA++ Core The core library requires at least GCC version 8 and the Boost libraries.\nsudo apt install libboost-filesystem-dev libboost-regex-dev libboost-program-options-dev build-essential gcc-8 git git clone https://github.com/applied-systems-biology/misaxx-core.git pushd misaxx-core mkdir build pushd build cmake -DCMAKE_BUILD_TYPE=Release .. make sudo make install popd popd MISA++ Analyzer The analyzer application requires an installation of the core libraries.\nsudo apt install libsqlite3-dev git clone https://github.com/applied-systems-biology/misaxx-analyzer.git pushd misaxx-analyzer mkdir build pushd build cmake -DCMAKE_BUILD_TYPE=Release .. make sudo make install popd popd MISA++ Imaging (OpenCV integration) The OpenCV integration requires OpenCV 3.x or 4.x.\nWe have experienced that multiple installations of OpenCV can lead to the build system making use of the wrong library files - even with CMake claiming to have found the correct version.\n sudo apt install libopencv-dev libtiff5-dev git clone https://github.com/applied-systems-biology/misaxx-imaging.git pushd misaxx-imaging mkdir build pushd build cmake -DCMAKE_BUILD_TYPE=Release .. make sudo make install popd popd MISA++ OME (OME TIFF integration) The OME TIFF integration requires an installation of misaxx-imaging and the OME Files library.\nWe have experienced issues with Boost 1.70 or higher in building the OME libraries. This is caused by a change in how Boost handles CMake targets.\n During the build process of OME Model, a Python2 script is used to generate C++ code. Due to lack of Python version specification, the script will crash if Python3 is the default Python. In this case, create a Python2 virtualenv and restart the build process.\n sudo apt install libxerces-c-dev libxalan-c-dev python wget libboost-all-dev git clone https://github.com/applied-systems-biology/misaxx-ome.git wget \u0026#34;https://downloads.openmicroscopy.org/ome-common-cpp/5.5.0/source/ome-common-cpp-5.5.0.zip\u0026#34; unzip ome-common-cpp-5.5.0.zip wget \u0026#34;https://downloads.openmicroscopy.org/ome-model/5.6.0/source/ome-model-5.6.0.zip\u0026#34; unzip ome-model-5.6.0.zip wget \u0026#34;https://downloads.openmicroscopy.org/ome-files-cpp/0.5.0/source/ome-files-cpp-0.5.0.zip\u0026#34; unzip ome-files-cpp-0.5.0.zip pushd ome-common-cpp-5.5.0 mkdir build pushd build cmake -DCMAKE_BUILD_TYPE=Release .. make sudo make install popd popd pushd ome-model-5.6.0 mkdir build pushd build cmake -DCMAKE_BUILD_TYPE=Release .. make sudo make install popd popd pushd ome-files-cpp-0.5.0 mkdir build pushd build cmake -DCMAKE_BUILD_TYPE=Release .. make sudo make install popd popd pushd misaxx-ome mkdir build pushd build cmake -DCMAKE_BUILD_TYPE=Release .. make sudo make install popd popd MISA++ OME Visualizer (Example application) This application allows visualization of int32 OME TIFF files and requires that misaxx-ome is installed.\ngit clone https://github.com/applied-systems-biology/misaxx-ome-visualizer.git pushd misaxx-ome-visualizer mkdir build pushd build cmake -DCMAKE_BUILD_TYPE=Release .. make sudo make install popd popd MISA++ Tissue segmentation (Example application) This application segments tissue from whole-organ light-sheet microscopy images and requires that misaxx-ome is installed.\ngit clone https://github.com/applied-systems-biology/misaxx-tissue.git pushd misaxx-tissue mkdir build pushd build cmake -DCMAKE_BUILD_TYPE=Release .. make sudo make install popd popd MISA++ Kidney glomeruli segmentation (Example application) This application segments the glomeruli in whole organ light-sheet microscopy images and requires that misaxx-tissue is installed.\ngit clone https://github.com/applied-systems-biology/misaxx-kidney-glomeruli.git pushd misaxx-kidney-glomeruli mkdir build pushd build cmake -DCMAKE_BUILD_TYPE=Release .. make sudo make install popd popd "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/building/windows-cygwin/",
	"title": "Building on Windows Cygwin",
	"tags": [],
	"description": "",
	"content": "We tested building on Windows via the Cygwin64 environment.\nPlease note that the Visual Studio compiler is not supported due to missing OpenMP 3.x capabilities.\n We consider building on Windows experimental due to unexplained freezing of multi-threaded workloads if started from ImageJ (running directly within the command line does not show this behavior).\n Prerequisites Download and install Cygwin64. Please consider our Readme file for a list of required packages.\nUsing the superbuild script We provide fully automated scripts that installs MISA++ Core, the modules we provide, and all necessary dependencies.\n Download or clone the MISA++ Utils repository Open an Cygwin shell and navigate into the windows-builds/cygwin folder Run ./build.sh Run ./package.sh  We cannot guarantee that all URLs within the build scripts stay valid forever. If a download fails, replace the URL in the affected build script.\n "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/building/windows-msys2/",
	"title": "Building on Windows MSYS2",
	"tags": [],
	"description": "",
	"content": " Update: Due to the rolling release nature of MSYS2, the MSYS2 build process is currently broken. The Boost 1.70+ library that is provided by MSYS2 is incompatible with OME libraries due to a change in CMake targets. Please use our guide for Cygwin to build MISA++ on Windows.\n We tested building on Windows via the MSYS2 environment.\nPlease note that the Visual Studio compiler is not supported due to missing OpenMP 3.x capabilities.\n We consider building on Windows experimental due to random crashes of compiled programs during starting. We were yet not able to find the cause of those crashes, although review using library inspection software hints at the inability to load dynamic libraries under certain circumstances.\n Prerequisites  Download and install MSYS2. Start MSYS2 (MinGW 64-bit) and update the packages by typing pacman -Syyu Let the process finish and close the terminal as instructed Restart MSYS2 (MinGW 64-bit)  Using the superbuild script We provide fully automated scripts that installs MISA++ Core, the modules we provide, and all necessary dependencies.\n Download or clone the MISA++ Utils repository Open an MSYS2 (MinGW 64-bit) shell and navigate into the windows-builds/msys2/superbuild-win32 folder Run ./superbuild.sh and follow the instructions  To create a distributable package of the MISA++ applications, run following command:\n./superbuild.sh ./package.py To create a Fiji distribution that comes pre-installed with MISA++ for ImageJ and the MISA++ applications, run following command:\n./superbuild.sh ./package.py ./package-fiji.sh  WarningThe OME libraries might be incompatible with the boost version provided by MSYS2 (Cannot find libraries). If this is the case four you, remove boost via pacman -R mingw-w64-x86_64-boost and remove the mingw-w64-$MSYS2_PLATFORM-boost \\ line in superbuild.sh.\nFirst make sure that patch is installed by running pacman -S patch.\nClone the MSYS2 package build script repository via git clone https://github.com/msys2/MINGW-packages.git and go back to the commit that contains the script to install Boost version 1.69 by navigating into the MINGW-packages repository and running git checkout fff2fc0d53aa95b85cee0c785e56159b0565ea72.\nNavigate into the mingw-w64-boost folder and run makepkg -si. The command will compile the correct Boost version and install it.\n Manually building Install the necessary MSYS2 packages:\npacman -S --noconfirm --needed unzip mingw-w64-x86_64-cmake \\ wget \\ mingw-w64-x86_64-toolchain \\ mingw-w64-x86_64-boost \\ mingw-w64-x86_64-make \\ libsqlite \\ libsqlite-devel \\ mingw-w64-x86_64-opencv \\ mingw-w64-x86_64-libtiff \\ mingw-w64-x86_64-xerces-c \\ mingw-w64-x86_64-xalan-c \\ mingw-w64-x86_64-libpng \\ mingw-w64-x86_64-python2 Obtain the MISA++ sources and the sources of dependencies that are not in MSYS2. Build them like any CMake build:\ncd $SOURCE_CODE mkdir build cd build cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=OFF -DCMAKE_INSTALL_PREFIX=/mingw64/ -G \u0026#34;Unix Makefiles\u0026#34; ..  Warning Building OME libraries dynamically caused segmentation faults during application runtime (Error 0xc0000005). Build the libraries statically to avoid the issue. Dynamically built MISA++ libraries caused random (~ every 10th execution) 0xc0000005 errors. We again decided to only link statically. OME Model requires OME_HOME to be set to /mingw64/ or any other folder that contains ./share/xml and ./share/xsl   "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/_header/",
	"title": "MISA++",
	"tags": [],
	"description": "",
	"content": "by Applied Systems Biology, HKI Jena, Germany"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/",
	"title": "MISA++",
	"tags": [],
	"description": "",
	"content": "Efficient. User friendly. MISA++ (Modular Image Stack Analysis for C++) combines the high efficiency of C++ with the user-friendliness of ImageJ with the option to extend its usage beyond image analysis. The framework consists of a high-performance C++ library and a standardized ImageJ plugin that provides a graphical user interface for any application built with our framework.\nMISA++ ImageJ plugin  Analyze images loaded in ImageJ Import results back into ImageJ Data and parameter management for any application developed with MISA++ Graphically create pipelines of MISA++ applications Extract and evaluate quantification results Create plots   Step-by-step tutorial  Download  MISA++ High-performance C++ framework  Fully automated and standardized parallelization Memory-efficient and standardized data management Standardized algorithm and sample parameters Standardized modularization Included support for OpenCV Included support for OME TIFF Can be easily extended with custom data types and algorithms In-code documentation Automatically generated human- and machine-readable documentation of data and parameters  The MISA++ framework was developed by Research Group Applied Systems Biology - Head: Prof. Dr. Marc Thilo Figge\nHKI-Center for Systems Biology of Infection\nLeibniz Institute for Natural Product Research and Infection Biology - Hans Knöll Insitute (HKI)\nAdolf-Reichwein-Straße 23, 07745 Jena, Germany\n "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/standards/module-info/",
	"title": "Module info",
	"tags": [],
	"description": "",
	"content": "The module information is accessible via the command line parameter \u0026lt;module\u0026gt; --module-info and as JSON file in MISA++ output folders (see Result folder).\nIt is data in JSON format with following structure:\nmermaid.initialize({startOnLoad:true}); graph LR; Root[\"root : object\"]--Id[\"id : string\"] Root --Version[\"version : string\"] Root -.-|Optional| Name[\"name : string\"] Root -.-|Optional| Description[\"description : string\"] Root -.-|Optional| Citation[\"citation : string\"] Root -.-|Optional| URL[\"url : string\"] Root -.-|Optional| License[\"license : string\"] Root -.-|Optional| Organization[\"organization : string\"] Root -.-|Optional| IsExternal[\"is-external : boolean\"] Root -.-|Optional| Authors[\"authors : array of string\"] Root -.-|Optional| Dependencies[\"dependencies : array of module info\"]  id Unique identifier of the module. Should be lower-case and only consist of letters a-z, 0-9 and -. Should be consistent with the module executable name.\nversion Version of the module.\nname Optional short and descriptive name.\ndescription Optional short description.\ncitation Optional citation referencing a publication that should be cited if a user wants to credit the module.\nurl Optional website URL.\nlicense Optional name of the license.\norganization Optional name of the organization that developed the module.\nis-external If true, the module info is marked as non-MISA++ dependency. Should be never true for information about a MISA++ module. Defaults to false if not defined.\nauthors Optional list of authors.\ndependencies Optional list of module info JSON objects that lists all dependencies.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/standards/parameter-schema/",
	"title": "Parameter schema",
	"tags": [],
	"description": "",
	"content": "The parameter schema can be automatically generated by any MISA++ application and contains all necessary information to create a parameter file (see Parameters).\nIt follows a modified JSON Schema draft-07 standard.\nModifications to JSON Schema draft-07 Property defitions can contain following additional properties:\n misa:documentation-title (optional string) provides a MISA++-internal documentation title misa:documentation-description (optional string) provides a MISA++-internal documentation description misa:documentation-type-title (optional string) provides a MISA++-internal documentation title. It describes the object type and can be different from misa:documentation-title. misa:documentation-type-description (optional string) provides a MISA++-internal documentation description. It describes the object type and can be different from misa:documentation-description misa:serialization-id (optional string) identifies the object property as MISA++ serializable type. The value is an unique identifier of the object type. misa:serialization-hierarchy (optional array of string) contains the inheritance hierarchy of the current misa:serialization-id  Structure The parameter schema describes the structure of the parameter file (see Parameters), including all sample and algorithm parameters.\nmermaid.initialize({startOnLoad:true}); graph LR; Root[\"root : object\"] Root -- Filesystem[\"filesystem : object\"] Filesystem -- FilesystemData[\"json-data : object\"] FilesystemData -- ImportedFSData[\"imported : object\"] FilesystemData -- ExportedFSData[\"exported : object\"] ImportedFSData -- ImportedFSDataChildren[\"children : object\"] ExportedFSData -- ExportedFSDataDataChildren[\"children : object\"] Root --Algorithm[\"algorithm : object\"] Root --Samples[\"samples : object\"] Root --Runtime[\"runtime : object\"]  filesystem Describes a filesystem using json-data (see Parameters). The information about each child in imported and exported is described within the additionalProperties definition in json-data/imported/children. See JSON Schema for more information about additionalProperties.\nadditionalProperties must be instanced into children for each sample algorithm Describes all sample-independent parameters. The structure is defined by the MISA++ application.\nsamples Describes the structure of the sample parameters. The parameters are described within the additionalProperties definition. See JSON Schema for more information about additionalProperties.\nadditionalProperties must be instanced for each sample "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/standards/parameters/",
	"title": "Parameters",
	"tags": [],
	"description": "",
	"content": "Parameters are in JSON format and have following structure:\nmermaid.initialize({startOnLoad:true}); graph LR; Root[\"root : object\"]--Filesystem[\"filesystem : object\"] Filesystem -- FilesystemSource[\"source : string\"] Filesystem -.-|if source is 'json'| FSJsonData[\"json-data : string\"] Filesystem -.-|if source is 'directories'| FSInputDir[\"input-directory : string\"] Filesystem -.-|if source is 'directories'| FSOutputDir[\"output-directory : string\"] Root --Algorithm[\"algorithm : object\"] Root --Samples[\"samples : object\"] Root --Runtime[\"runtime : object\"] Samples -.-|for each sample| SampleParams[\" : object\"] Runtime -.-|optional| NumThreads[\"num-threads : integer\"] Runtime -.-|optional| FullRuntimeLog[\"full-runtime-log : boolean\"] Runtime -.-|optional| RequestsSkipping[\"request-skipping : boolean\"]  filesystem Describes the virtual filesystem that is used by the MISA++ application.\nsource Determines how MISA++ imports the filesystem.\nFollowing values are valid:\n json imports the filesystem from json-data directories imports the filesystem from input-directory and output-directory  input-directory If source is directories, input data is imported from the provided directory. The folder structure must be consistent with the filesystem structure expected by the MISA++ application (see Parameter schema).\nEach data folder can contain a file misa-metadata.json in JSON format that has equivalent effects to the metadata property in json-data (see below).\noutput-directory If source is directories, output data is exported to the provided directory.\njson-data Imports the filesystem via the json-data property. It should be consistent with the filesystem parameter schema (see Parameter schema).\nThe json-data property has following structure:\nmermaid.initialize({startOnLoad:true}); graph LR; Root[\"json-data : object\"] Imported[\"imported : filesystem-entry\"] Exported[\"exported : filesystem-entry\"] Root -- Imported Root -- Exported FsEntry[\"filesystem-entry : object\"] FsEntry -.-|optional*| ExternalPath[\"external-path : string\"] FsEntry -.-|optional| Children[\"children : object\"] FsEntry -.-|optional| Metadata[\"metadata : object\"]  imported An object of type filesystem-entry. The external-path property must be set to a valid path.\nexported An object of type filesystem-entry. The external-path property must be set to a valid path.\nfilesystem-entry external-path Links the virtual filesystem entry to a physical filesystem location. Required for imported and exported.\nEntries in children automatically link to corresponding sub-folders in the path unless external-path of the child overrides the previous definition.\nchildren Map from directory name to a filesystem-entry type.\nmetadata Optional metadata for data import. The Parameter schema contains information about the structure of metadata.\nalgorithm Parameters that are independent from sample. The structure depends on the MISA++ application. See Parameter schema for more information.\nsample Map from sample name to sample parameters. The structure of sample parameters depends on the MISA++ application. See Parameter schema for more information.\nruntime Global parameter for the MISA++ runtime. The structure of sample parameters depends on the MISA++ application. See Parameter schema for more information.\nFollowing parameters are defined by MISA++ Core itself and are always present:\nnum-threads Number of threads. Must be at least 1.\nfull-runtime-log If true, a fully detailed runtime log (see Runtime log) is created. If false, only an overview is generated. Defaults to false.\nrequest-skipping If true, algorithms are informated that existing results should be re-used and not overwritten. Depends on the algorithm implementation. Defaults to false.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/standards/public-api/",
	"title": "Public API",
	"tags": [],
	"description": "",
	"content": "The public API of a MISA++ module should follow a specific structure to make it easier for other developers to use it.\n   File/Folder Contains     ./include/\u0026lt;module-name\u0026gt;/accessors/ Derivatives of misaxx::misa_cached_data   ./include/\u0026lt;module-name\u0026gt;/attachments/ Derivatives of misaxx::misa_serializable or misaxx::misa_locatable (preferred). For example quantified data.   ./include/\u0026lt;module-name\u0026gt;/caches/ Derivatives of misaxx::misa_cache   ./include/\u0026lt;module-name\u0026gt;/descriptions/ Derivatives of misaxx::misa_data_description   ./include/\u0026lt;module-name\u0026gt;/patterns/ Derivatives of misaxx::misa_data_pattern   ./include/\u0026lt;module-name\u0026gt;/utils/ Anything else (non-serializable data types, converters, helpers, \u0026hellip;)   ./include/\u0026lt;module-name\u0026gt;/module_interface.h Only for worker modules: A misaxx::misa_module_interface derivative   ./include/\u0026lt;module-name\u0026gt;/module.h Only for worker modules: A misaxx::misa_module derivative   ./include/\u0026lt;module-name\u0026gt;/module_info.h A function module_info() that returns a misaxx::misa_module_info    "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/standards/output-data/",
	"title": "Result folder",
	"tags": [],
	"description": "",
	"content": "MISA++ framework applications write their output into a folder that contains all neccessary information to repeat the analysis.\nThe folder has following structure:\nmermaid.initialize({startOnLoad:true}); graph LR; A[\"Result folder : directory\"] -- B[\"Parameters : file\"] A -- C[\"Module Info : file\"] A -- D[\"Parameter schema : file\"] A -- E[\"Runtime log : file\"] A -- G[\"Attachments : folder\"] G -- H[\"Attachment serialization schemata : file\"] G -.-|optional|I[\"imported : folder\"] G -.-|optional|J[\"exported : folder\"] I --|For each sample| K[\"Input data attachments : folder\"] J --|For each sample| L[\"Output data attachments : folder\"] A --|For each sample|F[\"Sample result data : folder\"]  Parameters A file parameters.json in JSON format. A copy of the input parameter file. See Parameters for more information.\nModule Info A file misa-module-info.json in JSON format. The same as the output of of \u0026lt;module\u0026gt; --module-info. See Module Info for more information.\nParameter schema A file parameter-schema.json in JSON format. See Parameter schema for more information.\nRuntime log A file runtime-log.json in JSON format. See Runtime log for more information.\nAttachments A folder attachments.\nAttachment serialization schemata A file serialization-schemas.json that contains serialization schemas for all attached objects. See Attachments for more information.\nimported An optional folder imported.\nInput data attachments A structure of folders that follows the data structure defined by the MISA++ application. Folders contain JSON files (extension .json). The files contain attached objects assigned to the data via the directory structure. See \u0026ldquo;Attachments\u0026rdquo; for more information.\nexported An optional folder exported.\nInput data attachments A structure of folders that follows the data structure defined by the MISA++ application. Folders contain JSON files (extension .json). The files contain attached objects assigned to the data via the directory structure. See \u0026ldquo;Attachments\u0026rdquo; for more information.\nSample result data A structure of folders that follows the data structure defined by the MISA++ application unless folders have been redirected via the filesystem. See Parameters for more information.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/standards/runtime-log/",
	"title": "Runtime log",
	"tags": [],
	"description": "",
	"content": "The runtime log contains detailed information about individual tasks executed by a MISA++ application.\nIt is in JSON format and has following structure:\nmermaid.initialize({startOnLoad:true}); graph LR; Root[\"root : object\"]--Entries[\"entries : object\"] Entries --|for each thread| ThreadEntry[\" : array of task-entry\"] TaskEntry[\"task-entry : object\"] -- Name[\"name : string\"] TaskEntry -- StartTime[\"start-time : number\"] TaskEntry -- EndTime[\"end-time : number\"] TaskEntry -- Unit[\"unit : string\"]  entries A map from thread$ where $ is the thread number to a list of task-entry.\ntask-entry name Name of the task.\nstart-time Time in unit relative to the MISA++ application start time when the task was started.\nend-time Time in unit relative to the MISA++ application start time when the task was ended.\nunit Unit of start-time and end-time.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/standards/serialization-id/",
	"title": "Serialization ID",
	"tags": [],
	"description": "",
	"content": "A serialization ID uniquely identifies an object type. It consists of two parts separated by a colon:\nmermaid.initialize({startOnLoad:true}); graph LR; M[\"Module\"] -- C[\":\"] C -- T[\"Type\"]  Module Lower-case string that consists only of a-z, 0-9 and -. Should be consistent with the module ID (see Module Info).\nType Lower-case string that consists only of a-z, 0-9, -, _ and / and should form a valid path.\nThe first segment of the path should be one of the following categories:\n attachments for quantification data and other attachments patterns for data patterns descriptions for data descriptions  misa:serialization-id is excluded from this rule.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]