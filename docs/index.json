[
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/building/",
	"title": "Building",
	"tags": [],
	"description": "",
	"content": "MISA++ uses the CMake build system (version 3.12 or higher) and is designed around the GCC compiler. We tested compilation under GCC version 7.3.\nIf you want to use another compiler, check if it supports C++ 2017 or higher and OpenMP 4.5 or higher. We only used OpenMP 3.x features, so using an older OpenMP version might work.\nYou will also need following additional libraries:\n   Library Version Notes     Boost 1.67    SQLite 3    OME files 0.5.0 See https://www.openmicroscopy.org/ for download and build instructions   OpenCV 4.0 OpenCV 3.x might also work   JSON for Modern C++ 3.5.0 See https://github.com/nlohmann/json    The MISA++ libraries and applications we provide depend on each other:\nmermaid.initialize({startOnLoad:true}); graph TB; A[MISA++ Core] -- B[MISA++ Imaging] A -- C[MISA++ Result Analyzer] B -- D[MISA++ OME] D -- E[\"MISA++ Tissue Segmentation\"] E -- F[\"MISA++ Kidney Glomeruli Segmentation\"] B -- G[\"MISA++ OME Visualizer\"]  Please make sure to build the dependencies the correct order.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/imagej/result-analyzer/output-data/",
	"title": "Evaluating output data",
	"tags": [],
	"description": "",
	"content": "The Data Browser tool lists all input and output data. Its navigation is similar to the parameter editor’s Data category (see Importing data).  \nDepending on the data type, the data browser offers actions such as importing the data back into ImageJ via Bioformats Importer. The “\u0026hellip;” button opens a list of other available options.\n\n\nFollowing actions are available by default:\n\n\nAction\n Description\n  Bioformats import\n Only available for OME TIFF data.\nImports the OME TIFF via the Bioformats importer.\n  Set current image name\n Only available for image data.\nSets the name of the currently selected image in ImageJ to a name unique to the data.\n  Open folder\n Opens the folder that contains the data.\n  Copy path\n Copies the folder path into the clipboard.\n  \n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/imagej/",
	"title": "ImageJ plugin",
	"tags": [],
	"description": "",
	"content": " The MISA++ (Modular image stack analysis for C++) framework allows the creation of C++ applications to process data. It features functions that simplify following common requirements of such applications:\n Automated parallelization of tasks Memory-efficient caching of data on hard-drive Providing additional algorithm parameters Modularization of common tasks Assigning quantitative results to data Integration into other tools and pipelines  MISA++ is used to develop modules that either provide additional data types and other utility functions (utility modules) or modules that are compiled into an application that solves a specific task (worker modules).\nWe also provide additional modules that integrate the open source imaging libraries OpenCV and OME Files into our framework.\nAll features Core library Creation of parallelizeable workloads  Easy creation of parallelizable and atomic tasks Easy structuring of tasks into groups Dependency management between workloads No need for manual thread creation due to automated parallelization  Standardized input parameters  Highly structured and well standardized way to create algorithm parameters Different parameter namespaces * Algorithm-specific parameters * Sample-specific parameters * Global parameters  Memory-efficient handling of large data sets  Data-access via thread-safe caches Easy importing of input data Easy creation of output data Methods to easily create new cache types  Assigning quantification results  Quantification results can be easily attached to input or output data Well-defined, fully-automated and portable way to assign quantification results to data for external tools Predefined data cache that acts as shared storage for quantified data  CMake build system integration  Automated generation of installable shared libraries Automated generation of installable executables for worker modules  Support for quantified data  Matrix data type including mathematical operations Values with unit * Unit conversions * Higher order units  Imaging capabilities OpenCV integration  Single-image cache Image stack cache * Allows access to each single-image cache * Easy parallelization  OME Files integration  OME TIFF cache that allows access to individual OME TIFF planes * Can read OME TIFF format including metadata * Can write OME TIFF format including metadata Automated conversion from/to OpenCV images Read and write access to OME metadata such as microscopy parameters or physical size Support for OME quantity types * Including higher-order quantity types such as area and volume * Voxel/3D quantity types  "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/imagej/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": " Building from source Building MISA++ for ImageJ requires the Maven build system and that a JDK installation is present on the current system.\n Download the source code Navigate into the source directory Run mvn package  The misa_imagej plugin can be found in the target directory. Copy it into the ImageJ plugin directory.\nMISA++ for ImageJ requires additional libraries that do not come pre-installed with ImageJ or Fiji.\nCopy following libraries from target/dependencies into the ImageJ jars directory:\n autolink flexmark graphics2d jfreesvg openhtmltopdf pdfbox poi sqlite bcprov-jdk15on bcpkix-jdk15on icepdf commons-exec  Windows superbuild MISA++ for ImageJ is part of the Windows superbuild. See Building for more information.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/development/prerequisites/",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": "MISA++ uses the CMake build system. Please make sure that CMake version 3.12 or higher is installed.\nThe compiler must support C++ version 2017 or higher.\nFor Windows, we recommend the MSYS2 environment.\nPlease note that the Visual Studio compiler is not supported due to missing OpenMP 3.x capabilities.\n Make sure that MISA++ Core and any other dependency modules are installed. See Building for more information about building MISA++ and already existing modules.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/imagej/result-analyzer/quantification-results/",
	"title": "Browsing quantification results",
	"tags": [],
	"description": "",
	"content": "MISA++ applications store quantification results in a standardized and flexible format that is capable of organizing large amounts of metadata. The data is stored as objects such as quantities with units, locations or application-specific objects such as glomeruli.  MISA++ for ImageJ includes a tool to filter, browse and process the quantification results and create tables of only the relevant information.\n Important: The tool is designed to handle millions of data entries and uses a SQLite database to handle such an amount of data. The database is created by the MISA++ Result Analyzer application. Please check if it is installed and in the list of available applications (see Managing applications).\n The user interface is divided into three sections:\n An interface to filter the quantification results\nA tree to navigate the filtered results\nThe selected object(s) displayed as table or object\n  The data flows from left to right: Quantification results are filtered by the filter tool and then displayed in the object tree. You can browse the tree and further refine your selection that will be displayed as table or object.\nFiltering To add a filter, click Add filter and select one of the filter types. Each filter has a button Remove filter that deletes the filter from the list and a toggle Disable filter that temporarily disables the filter without deleting it.\n Following filters are included in MISA++ for ImageJ:\n Filter\n Description\n  Filter by SQL\n Allows insertion of a custom SQL filter query.\n  Filter by data\n Filters quantification results that are attached to specific data.\n  Filter by object type\n Restricts the object types (e.g. only list glomeruli).\n  Filter by sample\n Only shows quantification results of specified samples.\n  Filter only direct attachments\n MISA++ quantification results are hierarchical. With this filter, objects deeper down in the hierarchy are hidden.\n     Tip: If you want to re-use the filters for your own SQLite query, click Copy filters as SQL query to obtain the query.\nObject tree The object tree lists all unfiltered objects in a hierarchy and acts as input for the table and object browser.\n The toolbar has following actions:\n Action\n Description\n  Automatically update\n If enabled (default), the tree is automatically updated when a filter is changed.\n Disable this feature if you change lots of filter settings at once and don’t want to wait for the database update.\n  Update\n Updates the tree manually.\n  Copy as SQL query\n Copies the current selection as SQL query. This includes the SQL query from filtering.\n  Display by data\n If enabled (default), the tree is organized by sample → data → sub-data → type → property.\n  Display by object type\n If enabled, the tree is organized by MISA++ application → type → data → sample → property.\n    Creating a table and browsing objects The data browser allows you to either browse the quantification results as objects or create a table (default option).\n The table creator has following actions:\n  Action\n Description\n  Automatically update\n If enabled (default), the table is automatically updated when a filter is changed or the selection the tree changes.\n  Update\n Updates the table manually.\n  Export\n Saves the table as *.csv or *.xlsx\n  Analyze\n Opens a tool to further analyze the table (see Summarizing quantification results).\n  Current object\n Tables can only be created for one object type. Use this selection to change the object type.\n  Edit columns\n By default, the table does not contain all properties of the current object. The column editor allows you to include more columns or exclude unnecessary information.\n    By changing the current mode from Table to Object list, all selected quantification data is displayed as objects. You can browse the list and export objects in JSON format.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/",
	"title": "C++ Framework",
	"tags": [],
	"description": "",
	"content": " The MISA++ (Modular image stack analysis for C++) framework allows the creation of C++ applications to process data. It features functions that simplify following common requirements of such applications:\n Automated parallelization of tasks Memory-efficient caching of data on hard-drive Providing additional algorithm parameters Modularization of common tasks Assigning quantitative results to data Integration into other tools and pipelines  MISA++ is used to develop modules that either provide additional data types and other utility functions (utility modules) or modules that are compiled into an application that solves a specific task (worker modules).\nWe also provide additional modules that integrate the open source imaging libraries OpenCV and OME Files into our framework.\nAll features Core library Creation of parallelizeable workloads  Easy creation of parallelizable and atomic tasks Easy structuring of tasks into groups Dependency management between workloads No need for manual thread creation due to automated parallelization  Standardized input parameters  Highly structured and well standardized way to create algorithm parameters Different parameter namespaces * Algorithm-specific parameters * Sample-specific parameters * Global parameters  Memory-efficient handling of large data sets  Data-access via thread-safe caches Easy importing of input data Easy creation of output data Methods to easily create new cache types  Assigning quantification results  Quantification results can be easily attached to input or output data Well-defined, fully-automated and portable way to assign quantification results to data for external tools Predefined data cache that acts as shared storage for quantified data  CMake build system integration  Automated generation of installable shared libraries Automated generation of installable executables for worker modules  Support for quantified data  Matrix data type including mathematical operations Values with unit * Unit conversions * Higher order units  Imaging capabilities OpenCV integration  Single-image cache Image stack cache * Allows access to each single-image cache * Easy parallelization  OME Files integration  OME TIFF cache that allows access to individual OME TIFF planes * Can read OME TIFF format including metadata * Can write OME TIFF format including metadata Automated conversion from/to OpenCV images Read and write access to OME metadata such as microscopy parameters or physical size Support for OME quantity types * Including higher-order quantity types such as area and volume * Voxel/3D quantity types  "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/running/",
	"title": "Running",
	"tags": [],
	"description": "",
	"content": " To run a module, you can either run it using a graphical user interface such as the MISA++ ImageJ plugin or run it directly via the command line.\nCommand line interface A worker module is an executable that has a command line interface (CLI). You can always run \u0026lt;module\u0026gt; --help to show all parameters.\nTo run a workload, run \u0026lt;module\u0026gt; --parameters \u0026lt;parameter file\u0026gt;. It will start doing the tasks and exits after they are done. The CLI also allows you to quickly change some runtime parameters without editing the parameter file. You can override the number of threads using --threads \u0026lt;number of threads\u0026gt; and enable the complete runtime log with --full-runtime-log.\nYou can also query the version and full module info in JSON format using --version and --module-info respectively.\nEach runnable module is able to create a description of its parameter file, input and output directory structure and data types. This parameter schema is generated using --write-parameter-schema \u0026lt;file\u0026gt;. No parameter file is necessary to generate a parameter schema.\nAll necessary information will also be written into the output directory after the module finishes its work.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/development/development-environment/",
	"title": "Setting up a project",
	"tags": [],
	"description": "",
	"content": " The MISA++ Core library contains a CMake script to simplify the creation of modules. The following documentation assumes that this script is used. You are free to setup your project without our helper script.\n Creating the folder structure Each module is designed to be compiled into a shared library (.dll/.so), which requires a strict separation between the API and implementation. Create following folder structure:\n./CMakeLists.txt ./include/\u0026lt;module-name\u0026gt;/ ./src/\u0026lt;module-name\u0026gt;/  \u0026lt;module-name\u0026gt; is the name of the CMake target, for example misaxx-ome. The include directory contains the public API of the module and will be installed into the global include directory. The src directory contains implementation-only files and will not be installed.\nCreating the CMakeLists.txt Fill the CMakeLists.txt file with following information:\ncmake_minimum_required(VERSION 3.11) # Or higher if required project(\u0026lt;module-name\u0026gt; VERSION \u0026lt;module-version\u0026gt; DESCRIPTION \u0026#34;\u0026lt;Short description\u0026gt;\u0026#34;)find_package(misaxx-core REQUIRED)# Add additional packages if necessary add_library(\u0026lt;module-name\u0026gt; \u0026lt;Files ...\u0026gt;)# Add additional link targets if necessary target_link_libraries(\u0026lt;module-name\u0026gt; misaxx::misaxx-core)# MISA++ helper script (automatically included by Core Library) set(MISAXX_LIBRARY \u0026lt;module-name\u0026gt;)set(MISAXX_LIBRARY_NAMESPACE \u0026lt;module-namespace\u0026gt;::)set(MISAXX_API_NAME \u0026lt;module_name\u0026gt;)set(MISAXX_API_INCLUDE_PATH \u0026lt;module-name\u0026gt;)set(MISAXX_API_NAMESPACE \u0026lt;module_name\u0026gt;)misaxx_with_default_module_info()misaxx_with_default_api()# Only if it\u0026#39;s a worker module: misaxx_with_default_executable() Please note that \u0026lt;module-name\u0026gt; and \u0026lt;module_name\u0026gt; might be different. \u0026lt;module_name\u0026gt; must be a name that is valid in C++.\nFor worker modules: Create the module interface and module dispatcher If you want to create a module that performs processing of data, create the following files:\n./include/\u0026lt;module-name\u0026gt;/module_interface.h ./include/\u0026lt;module-name\u0026gt;/module.h ./src/\u0026lt;module-name\u0026gt;/module_interface.cpp ./src/\u0026lt;module-name\u0026gt;/module.cpp  Please no not forget to add them to the CMakeLists.txt\nmodule_interface.h #include \u0026lt;misaxx/core/misa_module_interface.h\u0026gt; namespace \u0026lt;module_name\u0026gt; { struct module_interface : public misaxx::misa_module_interface { void setup() override; } }  module.h #include \u0026lt;misaxx/core/misa_module.h\u0026gt; namespace \u0026lt;module_name\u0026gt; { struct module : public misaxx::misa_module\u0026lt;module_interface\u0026gt; { using misaxx::misa_module\u0026lt;module_interface\u0026gt;::misa_module; void create_blueprints(blueprint_list \u0026amp;t_blueprints, parameter_list \u0026amp;t_parameters) override; void build(const blueprint_builder \u0026amp;t_builder) override; } }  Initial configuration Create a building directory and run cmake .. once. This will automatically generate additional code files such as the module info.\nmkdir build cd build cmake .. Add following files to your CMake target:\n./include/\u0026lt;module-name\u0026gt;/module_info.h ./src/\u0026lt;module-name\u0026gt;/module_info.cpp  "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/imagej/step-by-step/",
	"title": "Tutorial: Step by step analysis",
	"tags": [],
	"description": "",
	"content": " Prerequisites  Make sure that MISA++ Kidney Glomeruli Segmentation and MISA++ Result Analyzer are installed Make sure that the MISA++ ImageJ plugin is installed Download the example data  Video tutorial The video tutorial covers the same steps as the written tutorial.\n Written tutorial The following step-by-step tutorial shows the quantitative analysis of glomeruli by creating statistics and plots of their diameter.\n Start ImageJ and open the MISA++ plugin by navigating to Plugins → MISA++ for ImageJ. This will open a list of all available MISA++ applications. Select “MISA++ Kidney Glomeruli Segmentation”.\n Click Launch to open a tool that allows preparation of the data and changing parameters.\n     Click Import folder and select the folder that contains the example data set to automatically add samples and import images.\n     Select the folder that contains our example data set and click Open.\n Then delete the default sample “New Sample”, as we already imported all necessary data.\n    To enable multi-threading, select the Runtime tab and increase the number of threads.\n Click Run and then Run now to start the analysis. After the analysis finished, the plugin will ask you to further analyze the results.\n       Example: Analyzing results   The analysis tool displays a list of all output data and (if available) input data and allows importing data back into ImageJ.\nIf you want to import the glomeruli into ImageJ, click Bioformats Import next to the “glomeruli3d” data.\n   To analyze quantification results, click Browse quantification results.\n This will open a tool to browse and filter quantification results and transform them into tables that can be plotted.\n   To analyze the glomeruli, select Objects in the middle column and then “Glomerulus” above the table.\n   Due to performance reasons, the table does not contain all available information about each glomerulus. To add more, click Edit columns.\n Click Clear selection and select the columns  Sample\ndiameter/Value\ndiameter/Unit/unit\nValid\n    If you are happy with the table, click Analyze.  This will open a tool that allows you to modify the table and perform statistics.\n   To calculate mean and variance of the diameter, select a cell in the “diameter/value” column and navigate to Add column →  Copy selected column. Then click “OK”.\n      Click “Integrate columns” at the top right corner and assign following roles to each column:\n Sample: Category\ndiameter/unit/unit: Ignore\ndiameter/value: Average\nvalid: Category\ndiameter/value: Variance\n Click “Calculate”.\n   The table now shows the mean and variance of the glomeruli, categorized by the sample and if the glomerulus is valid according to the segmentation algorithm.\n Click Undo to restore the original table and then Create plot.\n   Set the plot type to Box Plot, set the category to “Table.Sample”, X axis to “Table.valid” and the list of values to the diameter.\n   "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/development/declaring-data/",
	"title": "Declaring data",
	"tags": [],
	"description": "",
	"content": " MISA++ organizes input and output data in caches. Caches provide functionality to access large datasets in a memory-efficient way. To be able to achieve this, they are linked to a location within the filesystem (a folder). The cache-implementation loads data into the memory on-demand and frees space if there is no demand left.\nCaches are exclusively created within the module interface that is also responsible for triggering the linking process between a folder and the cache implementation.\nDeclaring and linking caches To define that a cache is part of the interface, declare a variable of misa::misa_cached_data\u0026lt;T\u0026gt;. This instance is called an accessor, which is a shared pointer to the actual cache. Accessors are designed to include additional helper functions to make working with the specific cache type easier.\nLinking of a cache is done within the setup() method of the module interface. In most cases, it is most reasonable to use the suggest_import_location(...) or suggest_export_location(...) functions to link a cache.\nThe paths provided to suggest_import_location(...) and suggest_export_location(...) are relative to the virtual filesystem of the current module. The framework will automatically handle the organization of the files within the physical filesystem.\n Input data To declare input data, use the suggest_import_location(...) function. It loads a location from the filesystem if the cache was not already set from a parent module. Its first parameter, filesystem is the filesystem that is directly available from within the module interface. The second parameter describes the location within the input folder.\n The filesystem of a module interface is always relative. You do not have to account for your module being instantiated as a submodule.\n Output data suggest_export_location(...) creates a new location within the output folder that will contain the generated data. It has a third parameter that contains all necessary information for the cache to create an output. The type of this description differs from cache to cache.\nmermaid.initialize({startOnLoad:true}); graph TD; Description--|export|Cache Cache--|describe|Description Filesystem---|link|Cache  Example struct module_interface : public misa_module_interface { misaxx::ome::misa_ome_tiff m_input; misaxx::ome::misa_ome_tiff m_output; void setup(); } module_interface::setup() { m_input.suggest_import_location(filesystem, \u0026#34;input\u0026#34;); // Link to \u0026lt;input folder\u0026gt;/input  m_output.suggest_export_location(filesystem, \u0026#34;output\u0026#34;, m_input.describe()); // Link to \u0026lt;output folder\u0026gt;/output. The output cache will have the same properties as the input }   Accessing cached data Caches load data from hard disk on demand and are implemented in a way that minimizes read and write operations. Any cache accessor comes with 3 methods:\nreadonly_access \u0026lt;value_type\u0026gt; access_readonly(); write_access \u0026lt;value_type\u0026gt; access_write(); readwrite_access \u0026lt;value_type\u0026gt; access_readwrite();  Those methods create proxy objects that ensure the correct state of the cache.\nMake sure to not destroy the proxy objects prematurely. The cache might invalidate the data.\n Access via proxy-objects or accessor-specific helper methods is thread-safe and uses a shared mutex to allow multiple threads to read the data, but only one thread to write it.\nPlease be careful to not circumvent cache access, as it can lead to lost data or errors.\n Example void work() { auto access = m_input.access_readonly(); cv::countNonZero(access.get()); // Proxy object will be destroyed } "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/development/",
	"title": "Development",
	"tags": [],
	"description": "",
	"content": "To develop a MISA++ module, follow the steps as listed below:\n Installing prerequisites Creating the project Declaring input and output data Creating tasks, dispatchers and re-using other modules Attach quantification data during processing  If you want to extends the existing functionality of MISA++, take a look at our guide to create a new data type. It can also be helpful to take a look at our additional tips and tricks.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/download/",
	"title": "Download",
	"tags": [],
	"description": "",
	"content": " MISA++ for ImageJ MISA++ ready-to-use Fiji distribution We provide a ready-to-use Fiji distribution that comes pre-installed with MISA++ for ImageJ, MISA++ Kidney Glomeruli Segmentation, MISA++ Tissue Segmentation, MISA++ OME Visualizer and MISA++ Result Analyzer.\nDownload Fiji+MISA (Windows) ImageJ plugin If you only want the plugin or are using an operating system other than Windows, download following package:\nDownload plugin (Windows, Linux)  Our plugin is Open Source and licensed under BSD-2-Clause. You can find the code under following link:\nDownload source code  MISA++ High-performance framework The framework is Open Source and licensed under BSD-2-Clause.\nWindows super build source code If you use Windows, you can use our superbuild that automates downloading and installing of MISA++ and MISA++ for ImageJ. See our guide for more information.\nDownload Windows superbuild sources    Git repository   git clone https://github.com/applied-systems-biology/misaxx-utils.git   Source code You can find the source codes of the MISA++ framework, modules and applications under following links:\n   Library Source code Class reference     MISA++ Core Download source code  Open    MISA++ Imaging Download source code  Open    MISA++ OME Download source code  Open    MISA++ OME Visualizer Download source code  Open    MISA++ Tissue Segmentation Download source code  Open    MISA++ Kidney Glomeruli Segmentation Download source code  Open    MISA++ Result Analyzer Download source code  Open       Git repositories   git clone https://github.com/applied-systems-biology/misaxx-core.git git clone https://github.com/applied-systems-biology/misaxx-imaging.git git clone https://github.com/applied-systems-biology/misaxx-ome.git git clone https://github.com/applied-systems-biology/misaxx-ome-visualizer.git git clone https://github.com/applied-systems-biology/misaxx-tissue.git git clone https://github.com/applied-systems-biology/misaxx-kidney-glomeruli.git git clone https://github.com/applied-systems-biology/misaxx-analyzer.git   Logos Download following package for the MISA++ logos:\nDownload Logos Example data Our step by step guide requires you to download example data:\nDownload example data The example data was published by Klingberg et. al\n Klingberg, Anika, et al. \u0026ldquo;Fully automated evaluation of total glomerular number and capillary tuft size in nephritic kidneys using lightsheet microscopy.\u0026rdquo; Journal of the American Society of Nephrology 28.2 (2017): 452-459.\n "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/imagej/module-manager/",
	"title": "Managing applications",
	"tags": [],
	"description": "",
	"content": "The MISA++ ImageJ plugin can be launched by navigating to Plugins → MISA++ for ImageJ. This will open a tool that lists all installed MISA++ applications (modules) and add more modules. \n\n\n\nThe user interface is divided into three sections:\n The list of applications\nInformation and tools that are related to the current application\nA toolbar with global actions\n Application list This will list all currently known applications with a name, an unique identifier and the version.\nClick on an entry to select an application.\nCurrent application Following information is shown about the currently selected application:  Name\nUnique identifier and version\nFile that tells MISA++ for ImageJ that this application exists\nA short description\n \n\nYou have following available actions:\n\n\n Action\n Description\n   Show documentation\n Opens the manual of the selected application. This manual is not the same as the ImageJ plugin manual. It contains information like dependency libraries (including citations if provided) and all information to run the command line application without our ImageJ plugin.\n  Remove\n Removes the application from the list. This will not remove the application from your computer. If the application is installed system-wide the button is disabled.\n  Launch\n Opens a tool that allows you to analyze data with the selected application (see Analyzing data)\n   \n\nToolbar actions Following actions are available:\n\n\n Action\n Description\n   Refresh\n Updates the list of available MISA++ applications.\n  Add module \u0026hellip;\n Allows you to add a MISA++ application this is not installed system-wide. Open the MISA++ application executable to add it to the list.\n  Connect modules together \u0026hellip;\n Opens the pipeline builder tool (see Creating pipelines)\n  Analyze result \u0026hellip;\n Opens a tool to analyze the output of a MISA++ application (see Analyzing results)\n  Analyze runtime log \u0026hellip;\n Opens a developer-tool to analyze the runtime of a MISA++ application. See Analyzing the runtime for more information.\n  Help\n Opens the documentation.\n  \n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/imagej/result-analyzer/table-analyzer/",
	"title": "Summarizing quantification results",
	"tags": [],
	"description": "",
	"content": "You can modify, split and summarize tables extracted from quantification results or loaded via the import function. Following actions are available:\n\n\nAction\n Description\n  Export\n Exports the current table as *.csv or *.xlsx\n  Clone\n Clones the current table into a new table document. This will open a new tab.\n  Undo\n Undo the previous action. Please note that this function does not work for manually editing a table cell.\n  Add row\n Adds an empty row or copies rows from another table.\n  Add column\n Allows creation of a new empty column, copying the currently selected column or importing columns from another table.\n The Combine selected columns function creates a new column that combines the values of the existing column in the format Column1=Value1, Column2=Value2. Use this function to quickly merge multiple conditions into a single one.\n   Remove rows\n Removes the selected rows\n  Remove columns\n Removes the selected columns\n  Rename column\n Renames the selected column\n  Select whole row\n Expands the selection to the whole row\n  Select whole column\n Expands the selection to the whole column\n  Invert selection\n Inverts the current selection\n  Filter select\n Selects all rows that match with the selected values.\n Example\nThe table has two columns “Valid” and “Sample”. You want to select all rows where “Valid” = True and “Sample” = “Kidney1”. Select those values and click the filter selection button.\n  Autosize columns\n Resizes the columns, so they fit their contents.\n  Split columns\n Splits the values of one column by a set of category columns.\n Example\n Sample\n Valid\n Count\n  S1\n True\n 100\n  S1\n True\n 30\n  S1\n False\n 50\n  S2\n True\n 200\n    The column “Count” is split by “Sample” and “Valid”. Following table is generated:\n  Count WHERE Sample=S1, Valid=True\n Count WHERE Sample=S1, Valid=False\n Count WHERE Sample=S2, Valid=True\n  100\n 50\n 200\n  30\n          Integrate columns\n Creates column statistics such as sum, average, variance or median.   Convert selection\n Converts the selected cells by the selected conversion function (e.g. to a number)\n  Create plot\n Creates a plot from the table. See Plotting quantification results for more information.\n Info: The plot gets a copy of the table, so changes to the table do not affect an existing plot.\n  \n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/imagej/analyzing-data/",
	"title": "Analyzing data",
	"tags": [],
	"description": "",
	"content": "MISA++ applications require a specific set of parameters and that the input data is organized in a certain way. You can either setup those conditions manually (see the MISA++ application’s manual) or use the parameter editor tool that is provided by the MISA++ ImageJ plugin.\nSee Current application to see how to open the tool.\nOverview The user interface is divided into three sections:\n A toolbar with global actions\nAvailable settings, categorized into different tabs\nParameter validation results\n Toolbar actions The toolbar contains actions that affect multiple setting categories. Following actions are available:\n Action\n Description\n  Import parameters\n Imports a compatible parameter file. It will import:\n Samples (but not the data)\nAlgorithm parameters\nSample parameters\nRuntime parameters\n   Import folder\n Imports a folder that contains input data and creates new samples if necessary. The selected folder must follow a specific structure:\n It must contains sub-folders that represent the samples\nThe sample-folders are structured as seen in the “Data” category (see Adding data)\nIf the folder contains a parameters.json file, it will be loaded via the “Import parameters” action\n   Check parameters\n Triggers a manual check of all parameters (see Validating the current settings)\n  Export\n Exports the current data and parameters into a ready-to-use package for other computers if the current settings are valid (see Validating the current settings).\n This will copy all the data into the selected folder. Please make sure that the file system has enough space.\n This will not copy the the MISA++ application itself.\n  Run\n Executes the analysis on the current computer.\n When the data is successfully analyzed, you can directly analyze the results (see Analyzing results).\n  Help\n Provides access to the parameter editor documentation and the documentation of the current MISA++ application (Module documentation)\n    Managing samples To add samples, select the “Samples” category and click the “Add samples” button. You can enter the name of one samples or add multiple lines where each line correspond to one sample.\nNext to each sample, there are two available actions:\n Action\n Description\n  Rename sample\n Allows you to rename the sample. If the name already exists or is empty, nothing will happen.\n  Remove sample\n Removes the sample\n   Importing data MISA++ applications define which input data is required and which data is generated as output. Input data must be structured in a way expected by the application. The MISA++ ImageJ plugin provides a graphical user interface for importing data. The user interface is divided into three sections:\n The currently selected sample\nA tree to navigate the input and output data\nA list of input and output data\n To import data into a sample, select it in the list of available samples. To refine the data list if there are a lot of entries, use the tree and the “Filter …” bar.\n By default, the list will display input and output data. While the output data is only shown for reference, you are required to set input data via the user interface elements.\nEach data entry always has the following structure:\n  Input data interface element\n Description\n  Data type\n The type of the data.\n Tip: Hover your mouse over this element to show information about the data type\n  Name\n Name of the data. Also acts as internal location within the MISA++ application.   Importer settings\n User interface specific to the currently selected importer.\n  Current Importer\n The importer that provides the data to the MISA++ application.\n    Importers The ImageJ plugin is designed to be extendable via other plugins. This is for example needed if the MISA++ application defines data types outside of images and developers want to include support for this data type. It is also possible to integrate new types of image sources such as a link to an online database. By design, users can select from various importers that are responsible for providing all necessary files to the MISA++ application. To change the current importer, click the \"Current importer\" button and select it.\n We included following importers by default:\n  Importer\n Description\n  Folder link\n Supports any data type (is always available) and allows you to select a folder that contains the data.\n Hover your mouse over the button to see what kind of files are expected.\n  OME TIFF\n Only available if the data type is “OME TIFF”.\n Click the button to show possible image sources. If there are images loaded in ImageJ, you can import an image directly from ImageJ.\n    Sample and algorithm parameters Depending on the MISA++ application there are a wide variety of sample and algorithm parameters that can be changed in the Sample parameters and  Algorithm parameters categories.\nThe user interface is divided into three sections:\n Parameter tree\nView and filter options\nParameters\n  Depending on the MISA++ application, there can be many nested parameters. To navigate them, use the parameter tree. If you select an entry in the tree, the list of parameters will only show the selected value and its children.\nTo make navigation easier, you can hide sub-trees by deselecting Objects and filtering the list via the “Filter …” bar.\nBy default, the parameter list will limit the list of shown parameters. To disable this feature, select Whole tree.\n Use the parameter list to change the parameters. Hover your mouse over the interface elements (such as the parameter name) to show documentation if available.\n The Sample parameters category has an additional user interface element at the top of the parameter tree to select the current sample.\nRuntime parameters Runtime-parameters provide application-wide settings on the number of threads, how quantification data is written and additional settings specific to some data types.\nThe user interface is the same as for sample and algorithm parameters (see Sample and algorithm parameters).\nValidating the current settings Some actions such as running the MISA++ application require that all parameters are valid and all data is imported. The ImageJ plugin notifies about issues in the current settings via the status bar.\nIt will show “No errors found” if the parameters are valid and the error message if an issue was found. If there are multiple issues, click the error message to show a window that lists all errors.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/citation/",
	"title": "Citation",
	"tags": [],
	"description": "",
	"content": "Please cite following publication if you use our framework:\nPublication is currently in preparation. We will update this page when the publication is ready.  Thanks!\nThe MISA++ framework was developed by Research Group Applied Systems Biology - Head: Prof. Dr. Marc Thilo Figge\nHKI-Center for Systems Biology of Infection\nLeibniz Institute for Natural Product Research and Infection Biology - Hans Knöll Insitute (HKI)\nAdolf-Reichwein-Straße 23, 07745 Jena, Germany\n  \n  "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/imagej/result-analyzer/plot-builder/",
	"title": "Creating plots",
	"tags": [],
	"description": "",
	"content": "The integrated plot tool can create various plots from table data. The user interface is divided into three sections:\n The plot\nThe plot type and data import/export options\nPlot data and additional settings\n \n\nThe plot is displayed on the right side and can be exported into publication-ready formats via the Export action. You can disable the automatic update when plot settings or data is changed by disabling the Automatically update plot button.\n\n\nThe plot type can be selected in ②, which also has following actions:\n\n\nActions\n Description\n  Plot type\n The current plot type\n  Import data\n Imports columns from a table. Imported data series will be named \u0026lt;Table Name\u0026gt;.\u0026lt;Column Name\u0026gt;.\n Tip: Use the Rename buttons in the tab list to rename tabs.\n  Data as table\n Exports the currently loaded data as table.\n  \n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/development/creating-tasks/",
	"title": "Creating tasks",
	"tags": [],
	"description": "",
	"content": " The MISA++ framework manages workloads by parallelized execution of atomic tasks. Additionally, dispatchers can be created that acts as inner node within a tree of workers. Tasks on the other hand are always leaves.\nThe module dispatcher (./include/\u0026lt;module-name\u0026gt;/module.h) acts as root of this tree and as entry point to define the tasks that process data and their dependencies.\nTasks contain atomic workloads that should be able to run in parallel. All tasks inherit from misaxx::misa_task and require you to inherit following methods:\nvoid create_parameters(misaxx::misa_parameter_builder \u0026amp;parameters); void work();  The create_parameters() function comes with a parameter builder and allows you to create misaxx::misa_parameter\u0026lt;T\u0026gt; instances. The work() function is called when the work should be executed.\nCreating parameters To be able to automatically generate the parameter schema, the MISA++ framework requires you to initialize parameters within the create_parameters(...) function.\nExample struct my_task : public misa_task { using misa_task::misa_task; parameter\u0026lt;int\u0026gt; m_radius; void create_parameters(misaxx::misa_parameter_builder \u0026amp;parameters) { m_radius = parameters.create_algorithm_parameter\u0026lt;int\u0026gt;(\u0026#34;radius\u0026#34;, 10); // Will be independent of the current sample  } }   There are 3 types of parameters that are available:\n   Type Parameter.json path Description     Algorithm /algorithm/../..* Independent from current sample. Depends on name and path of current worker   Sample /samples/(current sample)/* Only depends on sample name.   Runtime /runtime/* Global    Accessing data Data is accessed via the module interface, or alternatively via cache accessor member variables. Access to the current module interface is available via the get_module() and get_module_as\u0026lt;T\u0026gt;() functions. This applies to all workers (tasks and dispatchers).\nExample struct my_task : public misa_task { using misa_task::misa_task; void work() { misaxx::ome::misa_ome_tiff tiff = get_module_as\u0026lt;my_module_interface\u0026gt;()-\u0026gt;m_input_data; // Do something with tiff  } }   "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/standards/",
	"title": "Standards",
	"tags": [],
	"description": "",
	"content": "The MISA++ framework defines various standards that make development of custom modules easier and allow fully automated interaction between MISA++ applications and external tools.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/imagej/result-analyzer/runtime-log/",
	"title": "Analyzing the runtime",
	"tags": [],
	"description": "",
	"content": "MISA++ applications always track basic information about the time needed to do an analysis with the option to enable a detailed runtime log. It can be accessed via the analysis tool (see Evaluating output data) or in a standalone-version that is accessible via the list of installed MISA++ applications (see Managing applications).\nThe timeline is a Gantt-chart that lists the duration and thread allocation of each calculation step. A full-detailed version that lists each individual task (e.g. tissue segmentation) is only available if enabled in the MISA++ application parameters.\n The tool also creates statistics such as the total runtime, estimated single-threaded runtime and the estimated multithreading speedup.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/development/creating-dispatchers/",
	"title": "Creating dispatchers",
	"tags": [],
	"description": "",
	"content": " The MISA++ framework manages workloads by parallelized execution of atomic tasks. Additionally, dispatchers can be created that acts as inner node within a tree of workers. Tasks on the other hand are always leaves.\nThe module dispatcher (./include/\u0026lt;module-name\u0026gt;/module.h) acts as root of this tree and as entry point to define the tasks that process data and their dependencies.\nDispatchers require you to override following virtual functions:\nvoid create_blueprints(misa_dispatcher::blueprint_list \u0026amp;blueprints, misa_dispatcher::parameter_list \u0026amp;parameters); void build(const misa_dispatcher::blueprint_builder \u0026amp;builder);  To allow the automated documentation of the whole tree of tasks, the misaxx::misa_dispatcher interface requires a data-independent declaration of all sub-dispatchers and tasks that the dispatcher might create, as well as all parameters that might be queried from the parameter file.\nThe function that defines all those available options is create_blueprints(...). After defining all possible tasks, sub-dispatchers and parameters, you can use them within the build(...) function.\nPlease keep in mind that create_blueprints(...) can be run in simulation mode (to acquire the parameter schema), which means that you should not query data or parameters from within the function without checking misaxx::runtime_properties::is_simulating().\n Creating and instantiating blueprints A \u0026ldquo;possible task/dispatcher\u0026rdquo; is called a blueprint and defined within the create_blueprints(...) function. The dispatcher class offers the create_blueprint\u0026lt;T\u0026gt;(...) method that creates such a blueprint. T can be any non-module dispatcher or task. The created blueprint must be added to the blueprint list to activate it.\nBlueprints are instantiated within the build(...) function by using the T \u0026amp;misa_dispatcher::blueprint_builder::build\u0026lt;T\u0026gt;() function.\nExample void module::create_blueprints(misa_dispatcher::blueprint_list \u0026amp;blueprint_list, misa_dispatcher::parameter_list \u0026amp;parameters) { blueprint_list.add(create_blueprint\u0026lt;my_task\u0026gt;(\u0026#34;my-task\u0026#34;)); // Announces a task \u0026#34;my-task\u0026#34;  create_blueprint\u0026lt;my_task\u0026gt;(\u0026#34;wrong\u0026#34;); // WRONG: Forgot to add it to the blueprint list } void module::build(const misa_dispatcher::blueprint_builder \u0026amp;builder) { builder.build\u0026lt;my_task\u0026gt;(\u0026#34;my-task\u0026#34;); // Instantiates a my_task \u0026#34;my-task\u0026#34;  builder.build\u0026lt;my_task\u0026gt;(\u0026#34;my-task\u0026#34;); // Can be done multiple times  builder.build\u0026lt;unregistered_task\u0026gt;(\u0026#34;wrong2\u0026#34;); // ERROR: Task is not registered  builder.build\u0026lt;unregistered_task\u0026gt;(\u0026#34;my-task\u0026#34;); // ERROR: \u0026#34;my-task\u0026#34; cannot be converted into unregistered_task  my_task_base \u0026amp;task = builder.build\u0026lt;my_task_base\u0026gt;(\u0026#34;my-task\u0026#34;); // NO error: If my_task inherits from my_task_base }   Instantiating workers does not mean that their work is executed. Instantiation only registers them into the runtime for later processing.\n Dependency management Instantiating a worker with build is sufficient if there are no dependencies between workers. If dependencies are required, dispatchers provide functionality to create dependencies between workers. The framework runtime automatically ensures that those dependencies are satisfied.\nYou can use following classes to easily define dependencies:\nmisaxx::misa_dispatcher::group misaxx::misa_dispatcher::chain  Groups A group can be used to group workers together. It has two operators \u0026lt;\u0026lt; and \u0026gt;\u0026gt; that allow adding workers to the group and assigning the group as dependency of another worker.\nExample void module::build(const misa_dispatcher::blueprint_builder \u0026amp;builder) { group parallelized; for (int i = 0; i \u0026lt; 3; ++i) { parallelized \u0026lt;\u0026lt; builder.build\u0026lt;A\u0026gt;(\u0026#34;A\u0026#34;); } parallelized \u0026gt;\u0026gt; builder.build\u0026lt;B\u0026gt;(\u0026#34;B\u0026#34;); }   The example builds a group of 3 tasks that have no specific order (they can be run in parallel) and another task that waits until all 3 tasks are finished. This is the dependency graph that is created: mermaid.initialize({startOnLoad:true}); graph TD A0[\"A\"]--B A1[\"A\"]--B A2[\"A\"]--B \nChains A chain allows easy creation of chain-dependencies. It only has a \u0026gt;\u0026gt; operator, but can be initialized with a set of dependencies.\nExample void module::build(const misa_dispatcher::blueprint_builder \u0026amp;builder) { group parallelized; for (int i = 0; i \u0026lt; 3; ++i) { parallelized \u0026lt;\u0026lt; builder.build\u0026lt;A\u0026gt;(\u0026#34;A\u0026#34;); } chain pipe {{ parallelized }}; pipe \u0026gt;\u0026gt; builder.build\u0026lt;B\u0026gt;(\u0026#34;B\u0026#34;) \u0026gt;\u0026gt; builder.build\u0026lt;C\u0026gt;(\u0026#34;C\u0026#34;) \u0026gt;\u0026gt; builder.build\u0026lt;D\u0026gt;(\u0026#34;D\u0026#34;); }   The example builds a group of 3 tasks that have no specific order (they can be run in parallel) and a chain of other tasks that are run strictly one-after-another. This is the dependency graph that is created:\nmermaid.initialize({startOnLoad:true}); graph TD; A0[\"A\"]--B; A1[\"A\"]--B; A2[\"A\"]--B; B--C; C--D;  "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/imagej/creating-pipelines/",
	"title": "Creating pipelines",
	"tags": [],
	"description": "",
	"content": "MISA++ applications can make usage of other MISA++ applications via a fixed code dependency. Creation of pipelines using code dependencies on the other hand requires modification of the source code. The MISA++ ImageJ plugin provides a tool that allows creation of pipelines of existing MISA++ applications without writing code.\nThe user interface is divided into four sections:\n Pipeline flow chart\nList of available MISA++ applications (modules) and an overview of samples\nToolbar with global actions\nParameter validation results (for all pipeline nodes)\n Pipeline flow chart The pipeline flow chart ( represents MISA++ applications as processing steps and data flow as arrow (connections) between processing steps.\nEach processing step consists of following components (from top to bottom):\n Component\n Description\n  Name\n The name of the processing step.\nCan be edited.\n  Description\n Optional description of the processing step. Can be edited.\n  Connect from other node\n Click to connect another processing step to the current one.\nThis button is not visible if there are no available connections.\n  Remove entry\n Removes the processing step.\n  Edit parameters\n Opens a parameter editor (see Analyzing data) for the MISA++ application behind the processing step.\n  Arrow(s) and Remove connection\n An arrow connects the data from one application to another. Click Remove connection to remove the connection.\n    Managing samples By default, all MISA++ applications within the pipeline have the same set of samples. You can disable this behavior by navigating the “Samples” tab next to the pipeline and disabling Autosync. The interface contains a list of all samples, color-coded by the MISA++ applications that work on the sample.\nBelow the list, you can find following actions:\n Action\n Description\n  Synchronize selected\n Ensures that the selected samples are represented in the same set of processing steps.\n Example\nWe have following configuration:\n   Sample1\n Sample2\n Sample3\n  Step 1\n   ✓\n    Step 2\n ✓\n ✓\n    Step 3\n   ✓\n ✓\n    If we synchronize Sample 1 and Sample 3, both of them will be in Step 2 and Step 3, but not Step 1.   Autosync\n If enabled (default), keeps samples synchronized across all processing steps.\n   Creating a pipeline To add an application to the pipeline, select an application and click Add to pipeline. This will create a new processing step in the flow chart. You can use your mouse to drag the processing step to any location in the flow chart.\n To implement the flow of data from one application to another, a connection must be created. Click the Connect from other node button on the target processing step and select the source processing step. This will create an arrow and will allow you to import data from another processing step.\nConnecting data Creating a connection between processing steps does not automatically connect the output of the source to the input of the target processing step. To connect data, open the parameter editor of the target processing step via Edit parameters and change the importer (see Importers) of the input data to Pipeline: \u0026lt;Name of the source processing step\u0026gt;. Then select the appropriate data from the available options.\nPipeline actions Following actions are available at in the toolbar (③):\n Action\n Description\n  Open\n Opens a pipeline description file.\nPlease note that while structure of the pipeline and its connections are imported, all non-pipeline input data (from outside sources such as ImageJ) must be manually set after loading the pipeline.\n  Save\n Saves the structure of the pipeline, including\n The processing steps\nSamples\nAlgorithm parameters\nSample parameters\nRuntime parameters\nPipeline connections (including importer settings)\n This will not save importer settings for non-pipeline data sources.\n  Check parameters\n Manually triggers a check if the settings of each processing step are correct. See Validating the current pipeline settings for more information.\n  Export\n Exports a ready-to-use package that processes the pipeline. The packages require that the MISA++ applications are installed on the current computer and includes all settings, parameters and data.\n The tool generates two feature-identical scripts run.sh (Linux) and run.py (any operating system) and saves the pipeline structure in pipeline.json.\n  Run\n Executes the pipeline on the current computer.\n  Help\n Opens the documentation.\n    Validating the current pipeline settings Similar to the analysis with one application (see Analyzing results), the pipeline builder will validate if the processing steps have valid parameters. See Validating the current settings for more information.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/glossary/",
	"title": "Glossary",
	"tags": [],
	"description": "",
	"content": " MISA++ application Application that uses the MISA++ CLI to create an executable from a MISA++ worker module.\nMISA++ worker module A MISA++ module that contains a module dispatcher, a module interface and a module info function.\nMISA++ module A library that follows the MISA++ public API standard and is built on MISA++ Core.\nModule interface A class that inherits from misaxx::misa_module_interface and is part of the public API of the module.\nModule dispatcher A class that inherits from misaxx::misa_module and is part of the public API of the module.\nModule info A function module_info() in the namespace of the MISA++ module that returns a misaxx::misa_module_info instance (see Module Info).\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/imagej/result-analyzer/",
	"title": "Analyzing results",
	"tags": [],
	"description": "",
	"content": "The MISA++ ImageJ plugin comes with a tool to analyze the results of a MISA++ analysis. If you run an analysis (single-application or pipeline) on the current computer, you are offered to open the results immediately. If you executed the analysis on another computer, without the ImageJ plugin or want to re-visit an old result, you can access the analysis tool via the module manager (see Managing applications).\n\n\nDue to the high standardization of MISA++ applications, you can analyze results of MISA++ application that are not installed or where the installed application is newer or older.\nThe user interface is divided into two sections:\n A toolbar with global actions\nTabs containing the results\n \n\nFollowing toolbar actions are available:\n\n\nAction\n Description\n  Open \u0026hellip;\n Opens a MISA++ application output folder.\n  Import table \u0026hellip;\n Imports an external table into the table analyzer (see Summarizing quantification results).\n  Browse data\n Opens the data browser (see Evaluating output data).\n  Browse quantification results\n Opens a tool to browse quantification results (see Browsing quantification results).  You can open as many tools as you want.\n  Analyze runtime\n Opens the runtime analysis tool (see Analyzing the runtime).\n  Help\n Opens the documentation.\n  \n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/references/",
	"title": "Class reference",
	"tags": [],
	"description": "",
	"content": "   Library Class reference     MISA++ Core Open    MISA++ Imaging Open    MISA++ OME Open    MISA++ OME Visualizer Open    MISA++ Tissue Segmentation Open    MISA++ Kidney Glomeruli Segmentation Open    MISA++ Result Analyzer Open     "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/development/dispatching-submodules/",
	"title": "Dispatching submodules",
	"tags": [],
	"description": "",
	"content": " You reduce the amount of code in your current project by off-loading work to another MISA++ module. The sub-module will be integrated into the current worker tree and benefit from better parallelization and less post-processing compared to running MISA++ applications in a pipeline.\nPrerequisites Modify the CMakeLists.txt and the cmake/*-config.in to add the submodule as dependency.\nExample In CMakeLists.txt find_package(misaxx-core REQUIRED)find_package(misaxx-tissue-segmentation REQUIRED)# Later: target_link_libraries(my-module PUBLIC misaxx::misaxx-tissue-segmentation) In cmake/*-config.in find_package(misaxx-core REQUIRED)find_package(misaxx-tissue-segmentation REQUIRED)  Submodules within the filesystem A submodule is created on a subfolder of the current virtual filesystem and therefore are handled similar to data. The name of the folder is set during the declaration of the submodule in a dispatcher\u0026rsquo;s create_blueprints function.\nmermaid.initialize({startOnLoad:true}); graph TD Main[\"main() root module\"] Main -- S1[\"Current module (Sample 1)\"] Main -- S2[\"Current module (Sample 2)\"] S1 -- D1(\"Data 1\") S1 -- D2(\"Data 2\") S2 -- D3(\"Data 1\") S2 -- D4(\"Data 2\") S1 == M1[\"Submodule\"] S2 == M2[\"Submodule\"]  Please do not name sub-modules like existing data. This also means that the name of a submodule must be unique across the whole module.\nThis does not apply to submodules of the submodules, as each sub-module gets its own virtual filesystem.\n Submodules are independent of the dispatcher where they are instantiated. They only depend on the filesystem of the instantiating module.\n Dispatching a submodule It is recommended to add submodules to the module interface. To do this, create an empty shared pointer to the submodule interface in the current module interface.\nstruct module_interface : public misaxx::misa_module_interface { std::shared_ptr\u0026lt;my_submodule::module_interface\u0026gt; m_submodule; }  Instantiate the pointer within the setup() function (see Creating dispatchers). Here you can also pass input data from the current module to the submodule.\nvoid setup() { m_submodule = std::make_shared\u0026lt;my_submodule::module_interface\u0026gt;(); // You have the option to directly set the input data of the submodule  m_submodule.m_input_images = this-\u0026gt;m_input_images; }  Like all dispatchers, submodules need to be added to the list of blueprints. It is recommended to do this in the module dispatcher. Use create_submodule_blueprint(...) instead of create_blueprint(...).\nThe create_submodule_blueprint(...) function requires you to give a name to the submodule and allows you to pass the submodule interface that was created within the module interface. The shared pointer will be automatically updated to follow the submodule dispatcher instead.\nmodule::create_blueprints(misa_dispatcher::blueprint_list \u0026amp;blueprints, misa_dispatcher::parameter_list \u0026amp;parameters) { blueprints.add(create_submodule_blueprint\u0026lt;my_submodule::module\u0026gt;(\u0026#34;my-submodule\u0026#34;, get_module_as\u0026lt;module_interface\u0026gt;()-\u0026gt;m_submodule)); }  Dispatch the submodule dispatcher just like any other dispatcher (see Creating dispatchers).\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/development/attaching-data/",
	"title": "Attaching data",
	"tags": [],
	"description": "",
	"content": " The attachment system allows easy attachment of any serializable data to a cache. It can be used to communicate between different tasks and generate quantification output. If the attachment data type supports adding information about its location (e.g. which image plane), the cache will automatically assign the most available information.\nAttaching data to a cache To attach data, just call the void attach\u0026lt;T\u0026gt;(...) member function of a cache accessor. To access an attachment, you can use the T \u0026amp;get\u0026lt;T\u0026gt;() member function, which will throw an exception if the type does not exist. Use the T \u0026amp;access\u0026lt;T\u0026gt;() function to either return an existing attachment or create a new one.\nAttachments are caches and therefore thread-safe.\nExample void my_task::work() { auto module = get_module_as\u0026lt;module_interface\u0026gt;(); module-\u0026gt;m_output.attach(my_attachment(\u0026#34;important\u0026#34;)); module-\u0026gt;m_output.get\u0026lt;not_in_output\u0026gt;(); // Throws an exception  module-\u0026gt;m_output.access\u0026lt;not_in_output\u0026gt;().important_stuff = true; // Safe access }  Creating a new attachment type Attachments inherit either from misaxx::misa_serializable or misaxx::misa_locatable. If you want a plain attachment, use misaxx::misa_serializable as base. The misaxx::misa_locatable interface additionally allows adding a location to the attachment. This location allows easy assignment of the data to the data its attached to.\nAny MISA++ serializable must override following virtual methods:\nvoid from_json(const nlohmann::json \u0026amp;j); void to_json(nlohmann::json \u0026amp;j) const; void to_json_schema(misaxx::misa_json_schema_property \u0026amp;t_schema) const; void build_serialization_id_hierarchy(std::vector\u0026lt;misaxx::misa_serialization_id\u0026gt; \u0026amp;result) const;  You additionally need to create following inline functions that are needed for JSON serialization.\ninline void to_json(nlohmann::json \u0026amp;j, const my_attachment \u0026amp;p) { p.to_json(j); } inline void from_json(const nlohmann::json \u0026amp;j, my_attachment \u0026amp;p) { p.from_json(j); }  The from_json and to_json members should be used to serialize or deserialize the object. The to_json_schema describes the JSON that is created/expected by the from_json and to_json members and is used to generate the parameter schema.\nEach serializable is assigned an unique serialization id. The build_serialization_id_hierarchy is used to create this ID.\nFrom and to JSON Just take a look at the JSON for Modern C++ documentation.\nDescribing the input and output JSON To be able to create the parameter schema, each serialzable object must describe the expected structure of the serialized JSON. The misaxx::misa_json_schema provides methods to do this.\nIt offers following methods:\n declare\u0026lt;T\u0026gt;(...) declares the current path as JSON of type T. The default value is the T() declare_optional\u0026lt;T\u0026gt;(...) allows providing a default value declare_required\u0026lt;T\u0026gt;(...) marks the property as a required property resolve() returns a sub-path of the current JSON schema path. It will create a child property if needed  Please keep in mind that the provided misaxx::misa_json_schema_property represents the \u0026ldquo;root\u0026rdquo; of the current JSON object. This means that you have to call the declare function on resolve(...) to register member variables.\nPortable serialization Each serializable type has an unique serialization id of type misaxx::misa_serialization_id. This id is part of a hierarchy of serialization ids that mirrors the inheritance hierarchy of the C++ class. This allows external programs to serialize even unsupported types with minimal loss of information.\nThe build_serialization_id_hierarchy is used to build this hierarchy. In most cases, it is sufficient to just add the serialization ID of the current class to the list of IDs provided in the parameter.\n Please do not forget to call build_serialization_id_hierarchy function of the parent class.\n Serialization IDs have two components:\n The module A path that describes the serialized object  The serialization ID should be consistent with the location in the public interface, which means that it should for example be misa_serialization_id(\u0026quot;my-module\u0026quot;, \u0026quot;attachments/my-attachment\u0026quot;.\nExample /** * We want this attachment to be assignable to a cache after the program has run. * Alternatively use misa_serializable */ struct my_attachment : public misaxx::misa_locatable { int count = 0; std::vector\u0026lt;double\u0026gt; variances; bool some_flag = false; void from_json(const nlohmann::json \u0026amp;j) { // As usual with nlohmann::json  count = j[\u0026#34;count\u0026#34;]; variances = j[\u0026#34;variances\u0026#34;].get\u0026lt;std::vector\u0026lt;double\u0026gt;\u0026gt;(); // An optional parameter:  if(j.find(\u0026#34;some-flag\u0026#34;) != j.end()) some_flag = j[\u0026#34;some-flag\u0026#34;]; } void to_json(nlohmann::json \u0026amp;j) const { // As usual with nlohmann::json  j[\u0026#34;count\u0026#34;] = count; j[\u0026#34;variances\u0026#34;] = variances; j[\u0026#34;some-flag\u0026#34;] = some_flag; } void to_json_schema(const misaxx::misa_json_schema \u0026amp;t_schema) const { // The schema is at the \u0026#34;root\u0026#34; of the object.  // This is for example helpful if you want to wrap a single value  // e.g. t_schema.declare_required\u0026lt;int\u0026gt;();  // if we read/write like this: this-\u0026gt;value = j; in from_json  // But we have member functions, so we need to use \u0026#34;resolve\u0026#34;  // Short and efficient for \u0026#34;count\u0026#34;:  t_schema.resolve(\u0026#34;count\u0026#34;).declare_required\u0026lt;int\u0026gt;(); // No additional info. This is sufficient  // some_flag is optional, so use the other method  t_schema.resolve(\u0026#34;some-flag\u0026#34;).declare_optional\u0026lt;bool\u0026gt;(false); // Default is false  // Use misa_json_property for extra fun  t_schema.resolve(\u0026#34;variances\u0026#34;).declare(misa_json_property\u0026lt;std::vector\u0026lt;double\u0026gt;\u0026gt;() .make_optional() .with_title(\u0026#34;Variances\u0026#34;) .with_description(\u0026#34;Optional variances\u0026#34;)); } void build_serialization_id_hierarchy(std::vector\u0026lt;misaxx::misa_serialization_id\u0026gt; \u0026amp;result) const { // Please do not forget to call the parent build_serialization_id_hierarchy() method!  misaxx::misa_locatable::build_serialization_id_hierarchy(result); // Add our own ID now  result.emplace_back(misaxx::misa_serialization_id(\u0026#34;my-module\u0026#34;, \u0026#34;attachments/my-attachment\u0026#34;)); } } // Important for nlohmann:json serialization // Do not forget them inline void to_json(nlohmann::json \u0026amp;j, const my_attachment \u0026amp;p) { p.to_json(j); } inline void from_json(const nlohmann::json \u0026amp;j, my_attachment \u0026amp;p) { p.from_json(j); }   "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/credits/",
	"title": "Credits",
	"tags": [],
	"description": "",
	"content": "The MISA++ C++ framework is written in C++ version 17 and depends on the following libraries and tools:\n\n\nLibrary\n Version\n URL\n Author/Citation\n  OpenMP\n 4.5\n https://www.openmp.org/\n Dagum, Leonardo, and Ramesh Menon. \u0026ldquo;OpenMP: An industry-standard API for shared-memory programming.\u0026rdquo; Computing in Science \u0026amp; Engineering 1 (1998): 46-55.\n  Boost Libraries\n 1.67\n https://www.boost.org/\n Beman Dawes, David Abrahams, Rene Rivera; Boost Community\n  SQLite\n 3\n https://www.sqlite.org/\n SQLite Consortium\n  OME-Files\n 0.5.0\n https://www.openmicroscopy.org/\n Linkert, Melissa, et al. \u0026ldquo;Metadata matters: access to image data in the real world.\u0026rdquo; The Journal of cell biology 189.5 (2010): 777-782.\nGoldberg, Ilya G., et al. \u0026ldquo;The Open Microscopy Environment (OME) Data Model and XML file: open tools for informatics and quantitative analysis in biological imaging.\u0026rdquo; Genome biology 6.5 (2005): R47.\n  OpenCV\n 4.0.1\n https://opencv.org/\n Bradski,G. (2000) The OpenCV Library. Dr Dobbs J. Softw. Tools.\n  JSON for Modern C++\n 3.5.0\n https://github.com/nlohmann/json\n Niels Lohmann\n  CMake\n 3.12\n  https://cmake.org/\n  Kitware Inc.\n  \n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/imagej/credits/",
	"title": "Credits",
	"tags": [],
	"description": "",
	"content": "The MISA++ ImageJ plugin depends on following libraries:\n\n\nLibrary\n Version\n URL\n Author/Citation\n  ImageJ\nImgLib2\n 2.0.0\n http://imagej.net/\n Rueden, Curtis T., et al. \u0026ldquo;ImageJ2: ImageJ for the next generation of scientific image data.\u0026rdquo; BMC bioinformatics 18.1 (2017): 529.\n  Gson\n 2.8.5\n https://github.com/google/gson\n Google LLC\n  Guava\n 26.0-jre\n https://github.com/google/guava\n Google LLC\n  JFreeChart\n 1.5.0\n http://www.jfree.org/jfreechart/\n Dave Gilbert\n  JFreeSVG\n 3.3\n http://www.jfree.org/jfreesvg/\n Dave Gilbert\n  flexmark-java\n 0.40.18\n https://github.com/vsch/flexmark-java\n Vladimir Schneider\n  Bioformats Plugin\n 6.0.0\n http://www.openmicroscopy.org/bio-formats/\n Linkert, Melissa, et al. \u0026ldquo;Metadata matters: access to image data in the real world.\u0026rdquo; The Journal of cell biology 189.5 (2010): 777-782.\n  SQLite JDBC Driver\n 3.25.2\n https://bitbucket.org/xerial/sqlite-jdbc\n Taro L. Saito\n  Apache POI\n 4.0.1\n https://poi.apache.org/\n Apache Software Foundation\n  ICEpdf\n 6.2.2\n http://www.icesoft.org/\n Icesoft Technologies Inc.\n  Apache Commons Exec\n 1.4.0\n https://commons.apache.org/proper/commons-exec/\n Apache Software Foundation\n  Breeze Icons\n -\n https://github.com/KDE/breeze-icons\n KDE e.V.\n  Font-Awesome-SVG-PNG\n -\n https://github.com/encharm/Font-Awesome-SVG-PNG\n Damian Kaczmarek, Dominykas Blyžė   \n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/development/creating-caches/",
	"title": "Creating caches",
	"tags": [],
	"description": "",
	"content": " This guide will show you how to create your own cache types. A cache data type consists of four different classes:\n The cache implementation The cache accessor A pattern A description  The cache implementation is responsible for dynamically loading and unloading data from/to a folder that is located within the filesystem. Such a folder on the other hand can contain many different files with different names, while an image file cache would for example look for a specific image file within this folder.\nInstead of cache-specific functions like a set_file(path) function, a description is used as input of a cache. It uses this description to set all internal parameters to function correctly. Descriptions are serializable, making them portable. The describe() function of a cache allows access to this description and implementation-independent modification of its values. This enables easy derivation of exported data from imported data.\nA description on the other hand just contains already defined parameters (like for example the filename), which does not solve the issue of caches containing vastly different files. Patterns are objects with the purpose of creating a description from its a folder in a filesystem.\nA cache accessor is a shared-pointer-like object with the purpose of allowing easy access to the functionality of a cache. You can use it to add convenient methods that make it easier to work with the specific cache type.\nThe module interface and workers access a cache only via a cache accessor.\n mermaid.initialize({startOnLoad:true}); graph TD; Pattern--|Produce|Description Description--|Link|Cache Cache--|Describe|Description Filesystem--|Produce|Description Accessor--|Access|Cache Accessor-.-I[\"Module interface\"]  The base types of the necessary cache components are:\n misaxx::misa_cache and any of misaxx::utils::access::cache for caches misaxx::misa_cached_data for accessors misaxx::misa_data_pattern for patterns misaxx::misa_data_description for desciptions  Creating the cache implementation We first show you to use our misaxx::misa_default_cache helper that automates many functions that you would need to define manually.\nThe misaxx::misa_default_cache helper requires three template arguments:\n A mutexed cache of type misaxx::utils::access::cache or misaxx::utils::access::memory_cache The pattern type The description type   Please make sure to create a cache-specific description type. This is needed to later identify the cache type. Optional for the pattern type.\n The mutexed cache is a utility type that models the actual read and write access of the cache implementation. If you create a cache with a small enough footprint that allows it to be stored within memory, you can use misaxx::utils::access::memory_cache instead.\nLinking, Simulating and Postprocessing The misaxx::misa_default_cache requires you to override following functions:\nDescription produce_description(const boost::filesystem::path \u0026amp;, const Pattern \u0026amp;); void do_link(const \u0026lt;Description\u0026gt; \u0026amp;t_description); void simulate_link(); // Optional void postprocess() // Optional  The produce_description() function is responsible for creating applying the pattern and generating a description that allows the link function to find all necessary data within the folder.\nThe main link function is do_link(). It takes the description type of the cache and allows you to setup all internal functionality to make reading and writing work. It is only called if the runtime is not creating a parameter schema.\nIf a parameter schema is created, simulate_link() is called instead. By default, it will ensure that describe() returns a storage that contains both the pattern and description type. If you want to add additional information, just override this method.\nExample // The parameter schema will have the information that the pattern looks for JSON files void my_cache::simulate_link() { describe()-\u0026gt;set(misa_file_pattern({ \u0026#34;.json\u0026#34; })); describe()-\u0026gt;access\u0026lt;misa_file_description\u0026gt;(); }  Postprocessing The postprocess() method will be called after the runtime has finished all tasks you can use it to clean up the cache or finalize the output.\nLocation and unique location A cache always has a location that corresponds to the location provided in the link function. It is automatically set by the default cache.\nAdditionally, there is an unique location that should always point to some file within the cache\u0026rsquo;s location folder (use get_location() to obtain it). Please do not forget to set this unique location using set_unique_location() somewhere in do_link()\nSub-caches You can define sub-caches that are manually linked during do_link(). Just make sure that their location is equal to the location of the main cache and that their unique location is unique.\nThread-safe data access A cache implementation always inherits from a mutexed cache of type misaxx::utils::access::cache. It will require you to override following methods as well:\nT \u0026amp;get() override; const T \u0026amp;get() const override; void set(T value) override; bool has() const override; bool can_pull() const override; void pull() override; void stash() override; void push() override;  The get and set functions do what you would expect. pull() is responsible for loading data into memory, while push() is responsible for writing the current data to files on the harddrive. push() should not clear the data. stash() will be called to do only this if necessary. can_pull() should return if loading is possible (e.g. if the file exists).\nAll methods are called from a thread-safe environment using a shared mutex:\n   Function Access     get shared   has shared   can_pull shared   pull exclusive   stash exclusive   push exclusive    Do not call get(), has(), etc. manually unless you know exactly what you do. Use readonly_access(), write_access() and readwrite_access() that are provided by the accessor!\n The cache accessor A cache accessor is a shared pointer to a cache implementation. It contains additional functions to interact with the cache.\nJust inherit from misa_cached_data\u0026lt;CacheImplementation\u0026gt;. You can also inherit from misa_description_accessors_from_cache\u0026lt;CacheImplementation, SELF\u0026gt; to automatically add convenient access to caches that are based on misa_default_cache.\nExample We will create a cache that provides access to an integer. It will be stored in a file, so it is sufficient to just use a file pattern and derive our description from misa_file_description.\nThe pattern /** patterns/integer_pattern.h */ struct integer_pattern : public misaxx::misa_file_pattern { // We only look for .integer files  integer_description() : misaxx::misa_file_pattern({ \u0026#34;.integer\u0026#34; }) { } protected: void build_serialization_id_hierarchy(std::vector\u0026lt;misa_serialization_id\u0026gt; \u0026amp;result) const override; } inline void to_json(nlohmann::json\u0026amp; j, const integer_pattern\u0026amp; p); inline void from_json(const nlohmann::json\u0026amp; j, integer_pattern\u0026amp; p);  The description /** descriptions/integer_description.h */ struct integer_description : public misaxx::misa_file_description { using misa_file_description::misa_file_description; protected: void build_serialization_id_hierarchy(std::vector\u0026lt;misa_serialization_id\u0026gt; \u0026amp;result) const override; } inline void to_json(nlohmann::json\u0026amp; j, const integer_description\u0026amp; p); inline void from_json(const nlohmann::json\u0026amp; j, integer_description\u0026amp; p);  The cache implementation /** caches/integer_cache.h */ struct integer_cache : public misaxx::misa_default_cache\u0026lt; misaxx::utils::access::cache\u0026lt;int\u0026gt;, integer_pattern, integer_description\u0026gt; { // Inherited from mutexed cache. Just plain I/O  int \u0026amp;get() { return m_value.get(); } const int \u0026amp;get() const { return m_value.get(); } void set(int v) { m_value = v; } bool has() const { return m_value.has_value(); } bool can_pull() const { return boost::filesystem::exists(m_path); } void stash() { m_value = std::nullopt; } void pull() { std::ifstream r; r.open(m_path.string()); int v; r \u0026gt;\u0026gt; v; m_value = v; } void push() { std::ofstream w; w.open(m_path.string()) w \u0026lt;\u0026lt; m_value.get(); } // Linkage, simulation \u0026amp; postprocessing protected: integer_description produce_description(const boost::filesystem::path \u0026amp;path, const integer_pattern \u0026amp;pattern) override { integer_description description; pattern.apply(description, path); // Functionality of misa_file_pattern  return description; } public: void do_link(const integer_description \u0026amp;description) override { // Just take the filename in this case  m_path = get_location() / description.filename; // VERY IMPORTANT  set_unique_location(m_path); } void postprocess() override { std::cout \u0026lt;\u0026lt; \u0026#34;Nothing\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } private: boost::filesystem::path m_path; std::optional\u0026lt;int\u0026gt; m_value; }  Cache accessor /** accessors/integer.h */ struct integer : public misaxx::misa_cached_data\u0026lt;integer_cache\u0026gt; { using misaxx::misa_cached_data\u0026lt;integer_cache\u0026gt;::misa_cached_data; // We add some additional functions for convenience  int get() const { auto access = readonly_access(); return access.get(); } void set(int value) { auto access = write_access(); access.set(value); } }   Sub-caches You can create sub-caches that allow access to individual parts of the data. They live within the same filesystem location and are linked in the do_link() method of the main cache.\nTo make it easier, we provide the misaxx::manual_cache type that can be used as base instead of misaxx::default_cache. It provides the same functionality, but does not require a pattern. Instead, the main cache should provide a valid description.\nIn the do_link() method, create an uninitialized accessor type of the sub-cache and set its data attribute manually. Then run force_link with the appropriate arguments. This will ensure that the sub-cache is registered correctly.\nExample void do_link(integer_description \u0026amp;description) override { decimals accessor; accessor.data = std::make_shared\u0026lt;decimals_cache\u0026gt;(); // Manual setup etc.  // Important:  decimal_description subcache_description; accessor.force_link(this-\u0026gt;get_location(), misa_description_storage::with(subcache_description)); // Store for later usage  this-\u0026gt;decimals = std::move(accessor); }   Without using misa_default_cache A cache implementation should inherit from misaxx::misa_cache and a mutexed cache (misaxx::utils::access::cache). It should override following methods:\n// Main function that applies the linkage process: void link(const boost::filesystem::path \u0026amp;t_location, const std::shared_ptr\u0026lt;misa_description_storage\u0026gt; \u0026amp;t_description); // Returns the pattern \u0026amp; description: std::shared_ptr\u0026lt;misa_description_storage\u0026gt; describe() const; // The absolute folder path where the data is located boost::filesystem::path get_location() const; // A filename or any other unique file (for an explanation see below) boost::filesystem::path get_unique_location() const; // Returns true if the cache has currently data bool has_data(); // Returns a \u0026#34;self-description\u0026#34; of the cache location std::shared_ptr\u0026lt;const misa_location\u0026gt; get_location_interface() const // Optionally: Run after all work is done void postprocess() // Additional methods might be necessary depending on the mutexed cache implementation  The link() method is provided with an absolute path within the filesystem and a description. The link() function is called independent of the simulation mode. This means you have to use misaxx:runtime_properties::is_simulating() to check if the runtime is actually processing data.\nPlease make sure that describe() always returns a non-empty description storage with both a pattern and description. This also applies for parameter schema generation.\n "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/development/tips/",
	"title": "Tips and tricks",
	"tags": [],
	"description": "",
	"content": " Interacting with the runtime The MISA++ runtime is responsible for managing parameters, generation of the parameter schema, managing caches and executing workers.\nThere are multiple interface functions avilable that allow extracting information from and manipulation of the runtime.\nmisaxx::runtime_properties Contains functions about the current set of workers, the number of threads, the root filesystem and information about the root module.\nThe most important function is misaxx::runtime_properties::is_simulating() that indicates if actual work should be done or a parameter schema is currently being generated.\nmisaxx::cache_registry Allows manual registration and de-registration of caches.\nmisaxx::parameter_registry Allows manual query of parameters, access to the parameter JSON data and parameter schema builder.\nWorking on streaming data MISA++ can be used to process that that is not (yet) fully present on the hard disk, but generated during the runtime. This is for example helpful for online analyses.\nA possible way is to implement a cache that acts as data source and offers functionality to query data that should be processed and a way to know if the analysis should be finished.\nAny MISA++ worker (tasks, dispatchers and module dispatchers) allows repetition of the workload. This does not include the parameter and blueprint generation. This functionality can be used to create new workers whenever new data is available.\nvoid create_blueprints(blueprint_list \u0026amp;blueprints, parameter_list \u0026amp;parameters) { blueprints.add(create_blueprint\u0026lt;online_analysis_dispatcher\u0026gt;(\u0026#34;online-analysis\u0026#34;)); } void build(const blueprint_builder \u0026amp;builder) { while(m_input_stream.has_new_data()) { online_analysis_dispatcher \u0026amp;worker = builder.build\u0026lt;online_analysis_dispatcher\u0026gt;(\u0026#34;online-analysis\u0026#34;); worker.m_input = m_input_stream.dequeue(); } if(!m_input_stream.is_finished()) { this-\u0026gt;repeat_work(); } } "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/_footer/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "By Applied Systems Biology, Leibniz Institute for Natural Product Research and Infection Biology – Hans Knöll Institute (HKI), Jena, Germany\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "by Applied Systems Biology, HKI Jena, Germany\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Efficient. User friendly. MISA++ (Modular Image Stack Analysis for C++) combines the high efficiency of C++ with the user-friendliness of ImageJ with the option to extend its usage beyond image analysis. The framework consists of a high-performance C++ library and a standardized ImageJ plugin that provides a graphical user interface for any application built with our framework.\nMISA++ ImageJ plugin  Analyze images loaded in ImageJ Import results back into ImageJ Data and parameter management for any application developed with MISA++ Graphically create pipelines of MISA++ applications Extract and evaluate quantification results Create plots   Step-by-step tutorial  Download  MISA++ High-performance C++ framework  Fully automated and standardized parallelization Memory-efficient and standardized data management Standardized algorithm and sample parameters Standardized modularization Included support for OpenCV Included support for OME TIFF Can be easily extended with custom data types and algorithms In-code documentation Automatically generated human- and machine-readable documentation of data and parameters   Download  The MISA++ framework was developed by Research Group Applied Systems Biology - Head: Prof. Dr. Marc Thilo Figge\nHKI-Center for Systems Biology of Infection\nLeibniz Institute for Natural Product Research and Infection Biology - Hans Knöll Insitute (HKI)\nAdolf-Reichwein-Straße 23, 07745 Jena, Germany\n  \n  "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/standards/attachments/",
	"title": "Attachments",
	"tags": [],
	"description": "",
	"content": " MISA++ comes with a system to attach quantification results and other information to input and output data. The information is stored within objects that are serialized into JSON format, including additional information such as the object type.\nAttachments are saved in the attachments/imported and attachments/exported folders within a MISA++ result folder. The files are structured according to the filesystem (see Parameters).\nAn attachment file has the following structure:\nmermaid.initialize({startOnLoad:true}); graph LR; Root[\"root : object\"]--|for each attachment|A[\" : misa-serializable\"] Root -- RootL[location : misa-location] S[misa-serializable : object] S -- Sid[misa:serialization-id : string] S -- Shierarchy[misa:serialization-hierarchy : array of string] S -.- O[\"Other properties\"] L[misa-location : misa-serializable] L -- FsLocation[filesystem-location : string] L -- FsULocation[filesystem-unique-location : string] L -- FsILocation[internal-location : string] L -.- O2[\"Other properties\"]  root The root of an attachment file is a JSON object that maps from misa:serialization-id to the attached object. It has an additional entry location that maps to a misa:location.\nmisa-serializable misa:serialization-id Unique identifier of the object type. Follows the Serialization ID standard.\nmisa:serialization-hierarchy A list of strings the describes the inheritance hierarchy of the object. The first entry is always misa:serializable. The last entry is always the current misa:serialization-id. The hierarchy is ordered from the most basic type to the current one.\nmisa-location Inherits all properties from misa:serializable.\nfilesystem-location Absolute path of the folder that contains the input or output data. Different parts of the data have the same filesystem-location.\nfilesystem-unique-location Absolute path to a file or folder within the the filesystem-location. Unique for each part of the data.\ninternal-location Internal MISA++ filesystem location.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/building/windows-msys2/",
	"title": "Building on Windows",
	"tags": [],
	"description": "",
	"content": " We tested building on Windows via the MSYS2 environment.\nPlease note that the Visual Studio compiler is not supported due to missing OpenMP 3.x capabilities.\n Prerequisites  Download and install MSYS2. Start MSYS2 (MinGW 64-bit) and update the packages by typing pacman -Syyu Let the process finish and close the terminal as instructed Restart MSYS2 (MinGW 64-bit)  Using the superbuild script We provide fully automated scripts that installs MISA++ Core, the modules we provide, and all necessary dependencies.\n Download or clone the MISA++ Utils repository Open an MSYS2 (MinGW 64-bit) shell and navigate into the superbuild-win32 folder Run ./superbuild.sh and follow the instructions  To create a distributable package of the MISA++ applications, run following command:\n./superbuild.sh ./package.py To create a Fiji distribution that comes pre-installed with MISA++ for ImageJ and the MISA++ applications, run following command:\n./superbuild.sh ./package.py ./package-fiji.sh Warning The OME libraries might be incompatible with the boost version provided by MSYS2 (Cannot find libraries). If this is the case four you, remove boost via pacman -R mingw-w64-x86_64-boost and remove the mingw-w64-$MSYS2_PLATFORM-boost \\ line in superbuild.sh.\nFirst make sure that patch is installed by running pacman -S patch.\nClone the MSYS2 package build script repository via git clone https://github.com/msys2/MINGW-packages.git and go back to the commit that contains the script to install Boost version 1.69 by navigating into the MINGW-packages repository and running git checkout fff2fc0d53aa95b85cee0c785e56159b0565ea72.\nNavigate into the mingw-w64-boost folder and run makepkg -si. The command will compile the correct Boost version and install it.\n  Manually building Install the necessary MSYS2 packages:\npacman -S --noconfirm --needed unzip mingw-w64-x86_64-cmake \\ wget \\ mingw-w64-x86_64-toolchain \\ mingw-w64-x86_64-boost \\ mingw-w64-x86_64-make \\ libsqlite \\ libsqlite-devel \\ mingw-w64-x86_64-opencv \\ mingw-w64-x86_64-libtiff \\ mingw-w64-x86_64-xerces-c \\ mingw-w64-x86_64-xalan-c \\ mingw-w64-x86_64-libpng \\ mingw-w64-x86_64-python2 Obtain the MISA++ sources and the sources of dependencies that are not in MSYS2. Build them like any CMake build:\ncd $SOURCE_CODE mkdir build cd build cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=OFF -DCMAKE_INSTALL_PREFIX=/mingw64/ -G \u0026#34;Unix Makefiles\u0026#34; .. Warning  Building OME libraries dynamically caused segmentation faults during application runtime (Error 0xc0000005). Build the libraries statically to avoid the issue. Dynamically built MISA++ libraries caused random (~ every 10th execution) 0xc0000005 errors. We again decided to only link statically. OME Model requires OME_HOME to be set to /mingw64/ or any other folder that contains ./share/xml and ./share/xsl    "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/standards/module-info/",
	"title": "Module info",
	"tags": [],
	"description": "",
	"content": " The module information is accessible via the command line parameter \u0026lt;module\u0026gt; --module-info and as JSON file in MISA++ output folders (see Result folder).\nIt is data in JSON format with following structure:\nmermaid.initialize({startOnLoad:true}); graph LR; Root[\"root : object\"]--Id[\"id : string\"] Root --Version[\"version : string\"] Root -.-|Optional| Name[\"name : string\"] Root -.-|Optional| Description[\"description : string\"] Root -.-|Optional| Citation[\"citation : string\"] Root -.-|Optional| URL[\"url : string\"] Root -.-|Optional| License[\"license : string\"] Root -.-|Optional| Organization[\"organization : string\"] Root -.-|Optional| IsExternal[\"is-external : boolean\"] Root -.-|Optional| Authors[\"authors : array of string\"] Root -.-|Optional| Dependencies[\"dependencies : array of module info\"]  id Unique identifier of the module. Should be lower-case and only consist of letters a-z, 0-9 and -. Should be consistent with the module executable name.\nversion Version of the module.\nname Optional short and descriptive name.\ndescription Optional short description.\ncitation Optional citation referencing a publication that should be cited if a user wants to credit the module.\nurl Optional website URL.\nlicense Optional name of the license.\norganization Optional name of the organization that developed the module.\nis-external If true, the module info is marked as non-MISA++ dependency. Should be never true for information about a MISA++ module. Defaults to false if not defined.\nauthors Optional list of authors.\ndependencies Optional list of module info JSON objects that lists all dependencies.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/standards/parameter-schema/",
	"title": "Parameter schema",
	"tags": [],
	"description": "",
	"content": " The parameter schema can be automatically generated by any MISA++ application and contains all necessary information to create a parameter file (see Parameters).\nIt follows a modified JSON Schema draft-07 standard.\nModifications to JSON Schema draft-07 Property defitions can contain following additional properties:\n misa:documentation-title (optional string) provides a MISA++-internal documentation title misa:documentation-description (optional string) provides a MISA++-internal documentation description misa:documentation-type-title (optional string) provides a MISA++-internal documentation title. It describes the object type and can be different from misa:documentation-title. misa:documentation-type-description (optional string) provides a MISA++-internal documentation description. It describes the object type and can be different from misa:documentation-description misa:serialization-id (optional string) identifies the object property as MISA++ serializable type. The value is an unique identifier of the object type. misa:serialization-hierarchy (optional array of string) contains the inheritance hierarchy of the current misa:serialization-id  Structure The parameter schema describes the structure of the parameter file (see Parameters), including all sample and algorithm parameters.\nmermaid.initialize({startOnLoad:true}); graph LR; Root[\"root : object\"] Root -- Filesystem[\"filesystem : object\"] Filesystem -- FilesystemData[\"json-data : object\"] FilesystemData -- ImportedFSData[\"imported : object\"] FilesystemData -- ExportedFSData[\"exported : object\"] ImportedFSData -- ImportedFSDataChildren[\"children : object\"] ExportedFSData -- ExportedFSDataDataChildren[\"children : object\"] Root --Algorithm[\"algorithm : object\"] Root --Samples[\"samples : object\"] Root --Runtime[\"runtime : object\"]  filesystem Describes a filesystem using json-data (see Parameters). The information about each child in imported and exported is described within the additionalProperties definition in json-data/imported/children. See JSON Schema for more information about additionalProperties.\nadditionalProperties must be instanced into children for each sample algorithm Describes all sample-independent parameters. The structure is defined by the MISA++ application.\nsamples Describes the structure of the sample parameters. The parameters are described within the additionalProperties definition. See JSON Schema for more information about additionalProperties.\nadditionalProperties must be instanced for each sample "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/standards/parameters/",
	"title": "Parameters",
	"tags": [],
	"description": "",
	"content": " Parameters are in JSON format and have following structure:\nmermaid.initialize({startOnLoad:true}); graph LR; Root[\"root : object\"]--Filesystem[\"filesystem : object\"] Filesystem -- FilesystemSource[\"source : string\"] Filesystem -.-|if source is 'json'| FSJsonData[\"json-data : string\"] Filesystem -.-|if source is 'directories'| FSInputDir[\"input-directory : string\"] Filesystem -.-|if source is 'directories'| FSOutputDir[\"output-directory : string\"] Root --Algorithm[\"algorithm : object\"] Root --Samples[\"samples : object\"] Root --Runtime[\"runtime : object\"] Samples -.-|for each sample| SampleParams[\" : object\"] Runtime -.-|optional| NumThreads[\"num-threads : integer\"] Runtime -.-|optional| FullRuntimeLog[\"full-runtime-log : boolean\"] Runtime -.-|optional| RequestsSkipping[\"request-skipping : boolean\"]  filesystem Describes the virtual filesystem that is used by the MISA++ application.\nsource Determines how MISA++ imports the filesystem.\nFollowing values are valid:\n json imports the filesystem from json-data directories imports the filesystem from input-directory and output-directory  input-directory If source is directories, input data is imported from the provided directory. The folder structure must be consistent with the filesystem structure expected by the MISA++ application (see Parameter schema).\nEach data folder can contain a file misa-metadata.json in JSON format that has equivalent effects to the metadata property in json-data (see below).\noutput-directory If source is directories, output data is exported to the provided directory.\njson-data Imports the filesystem via the json-data property. It should be consistent with the filesystem parameter schema (see Parameter schema).\nThe json-data property has following structure:\nmermaid.initialize({startOnLoad:true}); graph LR; Root[\"json-data : object\"] Imported[\"imported : filesystem-entry\"] Exported[\"exported : filesystem-entry\"] Root -- Imported Root -- Exported FsEntry[\"filesystem-entry : object\"] FsEntry -.-|optional*| ExternalPath[\"external-path : string\"] FsEntry -.-|optional| Children[\"children : object\"] FsEntry -.-|optional| Metadata[\"metadata : object\"]  imported An object of type filesystem-entry. The external-path property must be set to a valid path.\nexported An object of type filesystem-entry. The external-path property must be set to a valid path.\nfilesystem-entry external-path Links the virtual filesystem entry to a physical filesystem location. Required for imported and exported.\nEntries in children automatically link to corresponding sub-folders in the path unless external-path of the child overrides the previous definition.\nchildren Map from directory name to a filesystem-entry type.\nmetadata Optional metadata for data import. The Parameter schema contains information about the structure of metadata.\nalgorithm Parameters that are independent from sample. The structure depends on the MISA++ application. See Parameter schema for more information.\nsample Map from sample name to sample parameters. The structure of sample parameters depends on the MISA++ application. See Parameter schema for more information.\nruntime Global parameter for the MISA++ runtime. The structure of sample parameters depends on the MISA++ application. See Parameter schema for more information.\nFollowing parameters are defined by MISA++ Core itself and are always present:\nnum-threads Number of threads. Must be at least 1.\nfull-runtime-log If true, a fully detailed runtime log (see Runtime log) is created. If false, only an overview is generated. Defaults to false.\nrequest-skipping If true, algorithms are informated that existing results should be re-used and not overwritten. Depends on the algorithm implementation. Defaults to false.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/standards/public-api/",
	"title": "Public API",
	"tags": [],
	"description": "",
	"content": "The public API of a MISA++ module should follow a specific structure to make it easier for other developers to use it.\n   File/Folder Contains     ./include/\u0026lt;module-name\u0026gt;/accessors/ Derivatives of misaxx::misa_cached_data   ./include/\u0026lt;module-name\u0026gt;/attachments/ Derivatives of misaxx::misa_serializable or misaxx::misa_locatable (preferred). For example quantified data.   ./include/\u0026lt;module-name\u0026gt;/caches/ Derivatives of misaxx::misa_cache   ./include/\u0026lt;module-name\u0026gt;/descriptions/ Derivatives of misaxx::misa_data_description   ./include/\u0026lt;module-name\u0026gt;/patterns/ Derivatives of misaxx::misa_data_pattern   ./include/\u0026lt;module-name\u0026gt;/utils/ Anything else (non-serializable data types, converters, helpers, \u0026hellip;)   ./include/\u0026lt;module-name\u0026gt;/module_interface.h Only for worker modules: A misaxx::misa_module_interface derivative   ./include/\u0026lt;module-name\u0026gt;/module.h Only for worker modules: A misaxx::misa_module derivative   ./include/\u0026lt;module-name\u0026gt;/module_info.h A function module_info() that returns a misaxx::misa_module_info    "
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/standards/output-data/",
	"title": "Result folder",
	"tags": [],
	"description": "",
	"content": " MISA++ framework applications write their output into a folder that contains all neccessary information to repeat the analysis.\nThe folder has following structure:\nmermaid.initialize({startOnLoad:true}); graph LR; A[\"Result folder : directory\"] -- B[\"Parameters : file\"] A -- C[\"Module Info : file\"] A -- D[\"Parameter schema : file\"] A -- E[\"Runtime log : file\"] A -- G[\"Attachments : folder\"] G -- H[\"Attachment serialization schemata : file\"] G -.-|optional|I[\"imported : folder\"] G -.-|optional|J[\"exported : folder\"] I --|For each sample| K[\"Input data attachments : folder\"] J --|For each sample| L[\"Output data attachments : folder\"] A --|For each sample|F[\"Sample result data : folder\"]  Parameters A file parameters.json in JSON format. A copy of the input parameter file. See Parameters for more information.\nModule Info A file misa-module-info.json in JSON format. The same as the output of of \u0026lt;module\u0026gt; --module-info. See Module Info for more information.\nParameter schema A file parameter-schema.json in JSON format. See Parameter schema for more information.\nRuntime log A file runtime-log.json in JSON format. See Runtime log for more information.\nAttachments A folder attachments.\nAttachment serialization schemata A file serialization-schemas.json that contains serialization schemas for all attached objects. See Attachments for more information.\nimported An optional folder imported.\nInput data attachments A structure of folders that follows the data structure defined by the MISA++ application. Folders contain JSON files (extension .json). The files contain attached objects assigned to the data via the directory structure. See \u0026ldquo;Attachments\u0026rdquo; for more information.\nexported An optional folder exported.\nInput data attachments A structure of folders that follows the data structure defined by the MISA++ application. Folders contain JSON files (extension .json). The files contain attached objects assigned to the data via the directory structure. See \u0026ldquo;Attachments\u0026rdquo; for more information.\nSample result data A structure of folders that follows the data structure defined by the MISA++ application unless folders have been redirected via the filesystem. See Parameters for more information.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/standards/runtime-log/",
	"title": "Runtime log",
	"tags": [],
	"description": "",
	"content": " The runtime log contains detailed information about individual tasks executed by a MISA++ application.\nIt is in JSON format and has following structure:\nmermaid.initialize({startOnLoad:true}); graph LR; Root[\"root : object\"]--Entries[\"entries : object\"] Entries --|for each thread| ThreadEntry[\" : array of task-entry\"] TaskEntry[\"task-entry : object\"] -- Name[\"name : string\"] TaskEntry -- StartTime[\"start-time : number\"] TaskEntry -- EndTime[\"end-time : number\"] TaskEntry -- Unit[\"unit : string\"]  entries A map from thread$ where $ is the thread number to a list of task-entry.\ntask-entry name Name of the task.\nstart-time Time in unit relative to the MISA++ application start time when the task was started.\nend-time Time in unit relative to the MISA++ application start time when the task was ended.\nunit Unit of start-time and end-time.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/cpp-framework/standards/serialization-id/",
	"title": "Serialization ID",
	"tags": [],
	"description": "",
	"content": " A serialization ID uniquely identifies an object type. It consists of two parts separated by a colon:\nmermaid.initialize({startOnLoad:true}); graph LR; M[\"Module\"] -- C[\":\"] C -- T[\"Type\"]  Module Lower-case string that consists only of a-z, 0-9 and -. Should be consistent with the module ID (see Module Info).\nType Lower-case string that consists only of a-z, 0-9, -, _ and / and should form a valid path.\nThe first segment of the path should be one of the following categories:\n attachments for quantification data and other attachments patterns for data patterns descriptions for data descriptions  misa:serialization-id is excluded from this rule.\n"
},
{
	"uri": "https://applied-systems-biology.github.io/misa-framework/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]